<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zack&#39;s Notebook</title>
  <icon>https://www.gravatar.com/avatar/160a34b9a823cdf4e1e71bef53510a1c</icon>
  <subtitle>You rest, you rust. You rush, you crash.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangcabbage.cn/"/>
  <updated>2018-02-03T15:53:47.325Z</updated>
  <id>http://zhangcabbage.cn/</id>
  
  <author>
    <name>zhang_zack</name>
    <email>jiahua_zhang@foxmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>zhangcabbage.cn 2.0 发布说明</title>
    <link href="http://zhangcabbage.cn/2018/zhangcabbage-cn-2-0-%E5%8F%91%E5%B8%83%E8%AF%B4%E6%98%8E.html"/>
    <id>http://zhangcabbage.cn/2018/zhangcabbage-cn-2-0-发布说明.html</id>
    <published>2018-02-03T14:58:31.000Z</published>
    <updated>2018-02-03T15:53:47.325Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><p>年底之际，zhangcabbage.cn迎来重大改版，升级为2.0。下面详细介绍更新内容</p><a id="more"></a><hr><h2 id="发布摘要"><a href="#发布摘要" class="headerlink" title="发布摘要"></a>发布摘要</h2><p>16年搭建个人博客以来，断断续续更新着文章，尤其是17年7月份之后就很少打理。赶上闲暇，升级博客功能，以激励自己写作来锻炼自己的语言整合、知识梳理能力。网站升级的主要契机就是hexo中<code>多说</code>评论系统的关闭，导致原先博客评论系统的失效，这就是<a href="https://baike.baidu.com/item/%E8%9D%B4%E8%9D%B6%E6%95%88%E5%BA%94/13502" target="_blank" rel="noopener"><code>蝴蝶效应</code></a>啊</p><h2 id="更新特性"><a href="#更新特性" class="headerlink" title="更新特性"></a>更新特性</h2><ol><li><code>hexo</code> 主题 <code>next</code> 版本全新升级 5.0.1 -&gt; 5.1.4<br>由于已对<code>theme</code>进行深度定制，加上<code>next</code>中配置文件<code>_config.yml</code>已被反复修改配置，直接更新会覆盖已有配置，所以<code>hexo</code>主题更新比较困难，新版<code>next</code>已有相应解决办法。</li><li>增加文章详情：更新时间、字数统计、阅读时长<br><img src="/images/technology/hexo_1.png" alt="Alt text"></li><li>修改文章评论系统：多说 -&gt; liveRe<br><img src="/images/technology/hexo_2.png" alt="Alt text"></li><li>博客底部增加浏览<a href="https://baike.baidu.com/item/UV/59745" target="_blank" rel="noopener"><code>uv</code></a>和<a href="https://baike.baidu.com/item/pv/402?fr=aladdin" target="_blank" rel="noopener"><code>pv</code></a>，并隐藏<code>hexo强力驱动</code><br><img src="/images/technology/hexo_3.png" alt="Alt text"></li><li>博客增加加密文章，提供私人情感释放空间<br><img src="/images/technology/hexo_4.png" alt="Alt text"></li><li>添加博客顶部加载条<br><img src="/images/technology/hexo_5.png" alt="Alt text"></li><li>文章底部打赏文字不抖动<br><img src="/images/technology/hexo_6.png" alt="Alt text"></li><li>博客加速：页面压缩</li></ol><h2 id="参照链接"><a href="#参照链接" class="headerlink" title="参照链接"></a>参照链接</h2><p><a href="http://shenzekun.cn/hexo%E7%9A%84next%E4%B8%BB%E9%A2%98%E4%B8%AA%E6%80%A7%E5%8C%96%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B.html" target="_blank" rel="noopener">hexo的next主题个性化教程：打造炫酷网站</a><br><a href="http://buleshit.xyz/2017/02/17/hexo%E5%8D%9A%E5%AE%A2%E5%8A%A0%E9%80%9F%E4%B9%8B%E9%A1%B5%E9%9D%A2%E5%8E%8B%E7%BC%A9/" target="_blank" rel="noopener">hexo博客加速之页面压缩</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;p&gt;年底之际，zhangcabbage.cn迎来重大改版，升级为2.0。下面详细介绍更新内容&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://zhangcabbage.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="博客技术" scheme="http://zhangcabbage.cn/tags/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>18年校招面试总结</title>
    <link href="http://zhangcabbage.cn/2018/18%E5%B9%B4%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93.html"/>
    <id>http://zhangcabbage.cn/2018/18年校招面试总结.html</id>
    <published>2018-01-18T13:30:21.000Z</published>
    <updated>2018-01-23T08:56:36.790Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><p>三年之后又三年，三年之后又三年，快十年了老大。《无间道》里的这句话也是我想说的，终于我也要毕业找工作了（正巧又是本命年。这里对从17年3月份开始的春招实习面试，一直到9月份的秋招面试进行回顾总结，其中包括求职历程、面试题目、公司待遇等等方面。想看就点进来吧……<br><a id="more"></a></p><hr><p>更新历史</p><ul><li>2018.01.20：完成初稿</li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>研究生生涯是我做选择最多的一个阶段，让我更清晰的知道了我想要什么，也让我更深刻认识到 <code>选择比努力更重要</code> 。既然是面试总结，那直接先上总结表最清晰明了。</p><p>下表中<code>✔</code>表示最终成功拿到offer，<code>✘</code>表示没有拿到offer，具体情况见表头。</p><p>首先是<strong>春招实习投递状态</strong>，最早从3月初开学起投递。由于导师不放实习，最后选择了离学校最近的<code>今日头条</code>从4月12号开始偷摸实习。</p><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">投递公司</th><th style="text-align:center">投递时间</th><th style="text-align:center">无消息/放弃</th><th style="text-align:center">笔试未通过</th><th style="text-align:center">面试未通过</th><th style="text-align:center">实习offer</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">阿里</td><td style="text-align:center">3.07</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">腾讯</td><td style="text-align:center">3.10</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">网易</td><td style="text-align:center">3.10</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">网易有道</td><td style="text-align:center">3.15</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">搜狐</td><td style="text-align:center">3.13</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">美团</td><td style="text-align:center">3.14</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">今日头条</td><td style="text-align:center">3.16</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">华为</td><td style="text-align:center">3.16</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">CVTE</td><td style="text-align:center">3.16</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">完美世界</td><td style="text-align:center">3.23</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">美丽联合</td><td style="text-align:center">3.29</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">360</td><td style="text-align:center">4.02</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr></tbody></table><p>之后是<strong>校招投递状态</strong>，差不多从7月29号开始投递校招简历，一直到9月中下旬为止。</p><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">投递公司</th><th style="text-align:center">无消息/放弃</th><th style="text-align:center">简历/测评未通过</th><th style="text-align:center">笔试未通过</th><th style="text-align:center">面试未通过</th><th style="text-align:center">校招offer</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">猿辅导</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">今日头条</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">CVTE</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">华为</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">京东</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">搜狗</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">网易杭研</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">阿里杭州</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">第四范式</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">便利蜂</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">拼多多</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✔</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">58</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">链家</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">携程</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">蘑菇街</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">商汤科技</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">滴滴</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">18</td><td style="text-align:center">美团</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">19</td><td style="text-align:center">360</td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">20</td><td style="text-align:center">百度</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">21</td><td style="text-align:center">腾讯</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">22</td><td style="text-align:center">小红书</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">23</td><td style="text-align:center">好未来</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">24</td><td style="text-align:center">Hulu</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">25</td><td style="text-align:center">微软</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">26</td><td style="text-align:center">快手</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">27</td><td style="text-align:center">爱奇艺</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">28</td><td style="text-align:center">猫眼</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">29</td><td style="text-align:center">搜狐</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">30</td><td style="text-align:center">科大讯飞</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">31</td><td style="text-align:center">招银网络</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">32</td><td style="text-align:center">顺丰科技</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">33</td><td style="text-align:center">FreeWheel</td><td style="text-align:center">✘</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table><p>本文我将分<strong>春招</strong>和<strong>秋招</strong>对面试过公司的面试过程进行整理记录，记录的过程以罗列面试中面试官提出的问题的形式进行，作为面试总结记录这里并不会对面试问题给出答案，有兴趣可以自行解答或评论交流。</p><p>另外对IT方向进行一下说明，这也关系本文面试题目的方向。IT软件开发方向可以按语言来划分，程序猿语言技能都是 <strong>主语言+脚本语言</strong>，按主语言大体分为：C/C++、Java、JS这三类（我随便一说别喷我，逃。。。也可以按工作方向划分为：前端、后端、运维、数据分析、大数据、算法。大多数情况下是按后者来划分，毕竟语言相通性更强。我本身混杂着 <strong>后端和大数据开发</strong>，因而校招部分公司投递大数据开发、数据挖掘开发，部分公司投递后端开发岗位。</p><h2 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h2><p>实习对最后秋招影响还是不小的，一方面可以直接拿到实习转正保底offer，另一方面一个好的实习也是校招的敲门砖。当然也有它坏的一方面，可能会耽误后面校招的复习准备。</p><h3 id="阿里巴巴"><a href="#阿里巴巴" class="headerlink" title="阿里巴巴"></a>阿里巴巴</h3><p>阿里的面试总结单独成文，见 <a href="http://zhangcabbage.cn/2017/%E9%98%BF%E9%87%8C%E6%A0%A1%E6%8B%9B-%E6%A2%A6%E6%83%B3%E6%98%AF%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E7%9A%84%EF%BC%8C%E4%B8%87%E4%B8%80%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%91%A2.html">阿里校招回忆录</a>。</p><h3 id="腾讯"><a href="#腾讯" class="headerlink" title="腾讯"></a>腾讯</h3><p>腾讯暑期实习招聘内推会对投递人简历进行评估，分B、B+、A、A+、S等，A+以上会有提前面试资格，否则只能走统一面试通道。我简历评级A，所以只能等统一酒店面试。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 问熟悉C++不</span><br><span class="line">- 给了一个C++程序，找出错误</span><br><span class="line">- 写一个清除String字符串空格的程序，返回字符串中空格数</span><br><span class="line">- QQ登录服务器的负载均衡实现？</span><br><span class="line">- 一个分布式问题，一台机器向1W台机器下发文件，如何加快下发速度</span><br><span class="line">- 采用P2P的思路解决，然后面试官限定1W台机器只能和下发文件机器交互该如何解决？（这台机器受其带宽限制，分配带宽策略……</span><br><span class="line">- 如何实现一个数组shuffle，不使用内置random库？（关于伪随机算法的实现</span><br></pre></td></tr></table></figure><p></p><p>聊的不是很欢乐，GG</p><h3 id="网易"><a href="#网易" class="headerlink" title="网易"></a>网易</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 写一个单例模式（常见问题，给吹逼一波枚举单例</span><br><span class="line">- 枚举单例比DCL单例的优势</span><br><span class="line">- 写出枚举单例代码</span><br><span class="line">- 如何查看kafka数据是否堆积？</span><br><span class="line">- kafka多个消费者线程消费topic，其partition被均分到partition，如果某个消费者线程突然挂掉了，partition如何分配？</span><br><span class="line">- 其他一些常见的问题，无算法</span><br></pre></td></tr></table></figure><p>笔试之后大老远去西北旺网易北京总部面试，当时还在头条实习，特地请了一天假，谁知道就一轮面试。状态：拿到实习offer。</p><p>这里有个小插曲，当时网易hr打电话告诉我面试通过，问我是否接受offer暑期去实习。那么重点来了，我给回绝后，hr问我你拒绝网易是去了微软亚洲研究院了么？黑人问号脸，2333333….嗯，大网易国内第一</p><h3 id="网易有道"><a href="#网易有道" class="headerlink" title="网易有道"></a>网易有道</h3><p>同样也是西北旺网易北京总部那地儿，老远了。</p><h4 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 随便问了点项目，发现我的spark项目没啥可聊的，然后就开始手撕算法了</span><br><span class="line">- 给定一个数组，判断此数组是否为二叉搜索树的后续遍历，讲了一下思路，没让写代码</span><br><span class="line">- 从外至内顺时针循环打印二维数组，在纸上写代码</span><br><span class="line">- 给一个字符串写一个atoi函数转换成int，没有详细输入说明，自己考虑所有情况，手写代码</span><br></pre></td></tr></table></figure><p>这一面基本是手撕算法了，不过基本都是《剑指offer》上的题目了</p><h4 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">- 做的spark项目日志是如何收集上来的？引出hdfs和kafka</span><br><span class="line">- hdfs存储系统是怎么样的？</span><br><span class="line">- hdfs能存储什么类型文件？</span><br><span class="line">- 如果hdfs存储很多小文件会怎样，为什么？</span><br><span class="line">- 一个电脑，2G内存、4G磁盘，现在往这个hdfs中存放10M大小的文件，能存储多少个这样的文件？</span><br><span class="line">- hdfs默认块大小是多少？</span><br><span class="line">- 当存储多个小文件时，是往一个块中叠加存储还是重新开辟一个块来存储？</span><br><span class="line">- 项目中问什么要使用hdfs，有考虑其他方式么？</span><br><span class="line">- kafka如何保证数据一致性？</span><br><span class="line">- kafka如何保证数据不丢失？</span><br><span class="line">- 如果kafka集群有3台机器，冗余备份3份，这3个备份在集群中怎么分布？</span><br><span class="line"></span><br><span class="line">- 你知道java多线程的知识么，能大致讲一下么</span><br><span class="line">- ThreadLocal是干嘛的</span><br><span class="line">- ThreadLocal的实现原理？</span><br><span class="line">- concurrentHashMap如何实现的？</span><br><span class="line">- concurrentHashMap在put函数操作的时候，在哪里加锁了？</span><br><span class="line">- volatile有什么保证？（可见性和顺序性，成员变量读写操作的原子性）</span><br><span class="line">- 面试官写了一个volatile成员变量count，开了三个线程，每个线程分别count++，但是main函数中调用的是thread的run方法，问我这个程序会输出什么？</span><br><span class="line">- run和start方法的区别？</span><br><span class="line">- 你知道start方法内部是如何实现的么？</span><br><span class="line">- 你能说出你有什么办法让上面程序线程安全，正确么</span><br><span class="line">- 在我说出synchronized和ReentrantLock之后，问我他们是什么类型的锁？</span><br><span class="line">- 我说可重入锁之后问我，什么是可重入锁？</span><br><span class="line">- 那除了可重入锁，还有别的类型的锁么？</span><br><span class="line">- 我回自旋锁后，问我什么是自旋锁？</span><br><span class="line">- 继续问我还有什么办法能实现程序的正确？</span><br><span class="line">- 我回可以使用CAS，之后问我CAS是如何实现的？</span><br><span class="line">- 又说那你用cas改一下程序，让它安全。（直接使用AtomicInteger）</span><br><span class="line">- 还有其他办法么？（捂脸，想不到了，就不能给我一个应用场景么）</span><br><span class="line">- 能讲一下JVM么</span><br><span class="line">- 你知道有哪些GC方法么</span><br><span class="line">- 如果需要程序尽量大的吞吐率，如何选择GC器，为什么？</span><br><span class="line">- CMS并发标记怎么进行的？</span><br><span class="line">- 你有在项目中使用上面JVM的GC器选择么</span><br><span class="line">- JVM内存溢出怎么进行调试查找？</span><br><span class="line">- JVM内存溢出可能的区域有哪些？</span><br><span class="line">- 面试官说，最后再来考一道算法吧。给两个字符串，找出这两个字符串的最大公共子字符串长度，注意不是子序列</span><br><span class="line">- 我想了一下说出来dp的思路，然后面试官说写一下dp公式</span><br><span class="line">- 面试官说你有听说过LCS么，我说嗯，原来写过LCS</span><br><span class="line">- 然后面试官说：行，那把代码在纸上写出来吧</span><br></pre></td></tr></table></figure><p>考察挺全面，对语言、算法、大数据方向框架等，面试完直接告诉我技术面通过了，问我啥时候可以去实习，还带我见一下hr。总体感觉网易有道比网易技术强些……</p><h3 id="今日头条"><a href="#今日头条" class="headerlink" title="今日头条"></a>今日头条</h3><p>之前对今日头条并不是很了解，只听说对算法要求很高，后面在头条实习感觉也是非常欢乐，如果不是工作方向不是很喜欢必留无意了。后面会单独写一篇关于头条实习感触的文章，这段实习对我也是很大。</p><h4 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- spark的reduceby和groupby的区别</span><br><span class="line">- 算法：1，2 .... n的数组找出其中缺失的数</span><br><span class="line">- 算法：假如给的是一个字符串，可能有&quot;123456789101112&quot;，找出缺失的数（深度遍历）</span><br><span class="line">- mysql中两个表的inner join 和out join left区别</span><br><span class="line">- kafka的架构</span><br><span class="line">- kafka中zero-copy听说过么</span><br><span class="line">- 聊人生聊理想</span><br></pre></td></tr></table></figure><h4 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- kafka的消费者在消费的时候如何保证数据不丢失</span><br><span class="line">- kafka消费者消费topic时，集群如何维护offset（zookeeper为每一个partition维护一个offset）</span><br><span class="line">- 算法：一个n面的骰子，其各面的概率为a[1...n]，写一个骰子点数生成器</span><br><span class="line">- 由上题算法引申题目：解法中我用一个数组维护每个点的概率，如何只用一个double变量来维护？</span><br><span class="line">- 聊人生聊理想</span><br><span class="line">- 觉得在大公司还是在小公司好</span><br><span class="line">- 中途在头条吃了个饭</span><br><span class="line">- 讲讲多线程、线程池</span><br><span class="line">- python的装饰器你了解么？</span><br><span class="line">- python装饰器的应用场景</span><br></pre></td></tr></table></figure><h4 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- 项目中遇到的问题</span><br><span class="line">- 成绩排名</span><br><span class="line">- 最好的三个朋友的性格</span><br><span class="line">- 待过的最好的团队</span><br><span class="line">- 推荐书给hr</span><br><span class="line">- 对一面二面面试官的印象</span><br><span class="line">- 自己的偶像(吴军、吴恩达)</span><br><span class="line">- 兴趣爱好</span><br><span class="line">- 职业规划，未来目标</span><br><span class="line">- 除了兴趣爱好和技术对企业其他方面还有没有关注（扯京东阿里的定位，菜鸟网络的模式等</span><br><span class="line">- 如何学习技术等等</span><br></pre></td></tr></table></figure><p>光hr面竟然面了1个半小时，orz</p><h3 id="360"><a href="#360" class="headerlink" title="360"></a>360</h3><p>360官网投递，最后是去360一家子公司面试，叫<code>360天广汇通</code>。</p><h4 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 写一个单例模式？</span><br><span class="line">- 枚举实现单例有什么好处？</span><br><span class="line">- Java多线程创建方式？（Thread、Runnable、线程池）</span><br><span class="line">- 线程池相关问题？</span><br><span class="line">- kafka架构？</span><br><span class="line">- kafka同一消费者组中消费者个数为什么不能多于topic下的partition个数？</span><br><span class="line">- O(1)时间删除链表某个结点</span><br></pre></td></tr></table></figure><h4 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h4><p>基本没问啥有营养的问题</p><h4 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 对http的了解？</span><br><span class="line">- TCP长连接、短连接的区别</span><br><span class="line">- TCP长连接长时间不发送数据，会不会断开？</span><br><span class="line">- 如何维持一个TCP长连接？</span><br><span class="line">- 你常用的Java数据结构（数组、list、map）？</span><br><span class="line">- 为啥hashmap需要同时重载equals和hashcode？</span><br><span class="line">- hashtable和concurrentHashMap的性能差别？</span><br><span class="line">- 线程池、数据库池的作用</span><br><span class="line">- 分布式系统的三个特性？</span><br><span class="line">- CAP能不能三个都保证？</span><br><span class="line">- 如何保证分布式系统的一致性？</span><br><span class="line">- 如何设计实现一个Java定时任务，让一个陷入死循环的线程某一段时间之后停止？（orz，最后面试官告诉我Java中实现不了</span><br><span class="line">- 问我最近在看啥书？（脑袋抽了，说操作系统）</span><br><span class="line">- 操作进程调度方式？</span><br><span class="line">- 什么情况下会进行进行调度？</span><br></pre></td></tr></table></figure><p>拿到实习offer，最后拒绝了。</p><h3 id="CVTE"><a href="#CVTE" class="headerlink" title="CVTE"></a>CVTE</h3><p>第一次知道这家公司，听室友说待遇还不错，跟风投了一下。</p><h4 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h4><p>一面是电话面试<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 讲讲后台开发项目经历</span><br><span class="line">- hdfs的文件系统架构</span><br><span class="line">- hdfs如何实现数据容错性</span><br><span class="line">- hdfs数据冗余备份策略</span><br><span class="line">- hadoop和spark的区别</span><br><span class="line">- spark当在中间数据在内存中访问不到时，是怎么处理的；或者说中间数据过大spark是如何处理的？</span><br><span class="line">- mapReduce过程中数据偏移严重时如何解决？</span><br><span class="line">- 刚才你讲项目时，说家电和云端通信，使用的是什么网络协议或者框架的？</span><br><span class="line">- 家电和云端的长连接是建立在什么协议上的？</span><br><span class="line">- TCP协议是如何建立连接和断开连接的？</span><br><span class="line">- 能给我讲讲OSI是哪七层么？</span><br><span class="line">- 你还知道其他网络协议么，比如http？</span><br><span class="line">- http协议request头部有哪些字段？</span><br><span class="line">- http协议状态码有哪些？</span><br><span class="line">- 你还对哪些技术感兴趣？</span><br></pre></td></tr></table></figure><p></p><h4 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- 介绍项目经历</span><br><span class="line">- 技术特长</span><br><span class="line">- spark作业提交之后的处理流程</span><br><span class="line">- spark有哪些组件</span><br><span class="line">- 解释一下spark的RDD、Dstream、DataSet、DataFrame这些概念</span><br><span class="line">- spark如何进行优化</span><br><span class="line">- 面试选择后台，还是大数据？</span><br><span class="line">- 后台项目经历</span><br><span class="line">- 介绍一下Java异常处理机制</span><br><span class="line">- 什么情况下会throw异常，什么情况下回catch这个异常</span><br><span class="line">- 编程中常遇到的异常有哪些？</span><br><span class="line">- Java内存溢出和内存泄漏的区别？</span><br><span class="line">- 使用过那些数据库</span><br><span class="line">- 关系型数据库和非关系型数据库的区别？</span><br><span class="line">- 结构化数据和关系型数据是不是等同的</span><br><span class="line">- 你使用mysql除了增删改查之外，还用来干过什么</span><br><span class="line">- mysql有哪些常见的优化方法</span><br><span class="line">- mysql什么时候需要建立索引</span><br></pre></td></tr></table></figure><p>二面是视频面试，表现不是很好，果不其然挂了……一定要早些选定好自己大体方向，毕竟应届生也没有那么多精力各方面都精通</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><p>华为的面试太水了，基本啥问题都没问，介绍一下项目一面过了，谈谈人生聊聊理想又一面过了。</p><h2 id="秋招"><a href="#秋招" class="headerlink" title="秋招"></a>秋招</h2><p>如果认真看到了这儿，你是真爱粉喏。尝试解答以上面试题目，如果对你一点难度都没有那请收下我的膝盖，谢谢大佬赏脸关注，欢迎来跟我搞基。</p><p>下面严肃的进入秋招。<code>养兵千日，用在今朝</code>。校招是一场考验心力耐力的大战……</p><h3 id="猿辅导"><a href="#猿辅导" class="headerlink" title="猿辅导"></a>猿辅导</h3><p>实习一天500的公司，虽然是个小公司，但是给人的感觉非常舒服。</p><h4 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 聊项目</span><br><span class="line">- python中L.append()如何实现原子操作</span><br><span class="line">- 线程池的优势</span><br><span class="line">- 生产者消费者模式如何保存数据</span><br><span class="line">- TCP断开的过程</span><br><span class="line">- 求二叉树中根到叶子结点的路径中和为sum的所有路径，写程序</span><br><span class="line">- 最大连续子数组和（非首尾相接），写程序</span><br></pre></td></tr></table></figure><p>面试官看了我的Github，说我刷了很多leetcode对面试很有用之类的话。Github、博客之类的有干货要好好维护呀，简历亮点哦！！</p><h4 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 继承的缺点是什么</span><br><span class="line">- 设计模式你还了解些什么</span><br><span class="line">- 聊聊其他兴趣爱好，数据挖掘比赛的事情</span><br><span class="line">- 问一道小题：用一个数组实现一个环形缓冲区，实现void put(byte[] date)和byte[] get(n)两个方法</span><br></pre></td></tr></table></figure><p>拿到offer。猿辅导公司待遇还是很有竞争力的：每年一次出国5000旅游经费、五一9天长假等等</p><h3 id="京东"><a href="#京东" class="headerlink" title="京东"></a>京东</h3><h4 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- 如何实现序列化问题（类似protocol buffer的方式）</span><br><span class="line">- hashmap和hashtable的区别</span><br><span class="line">- hashmap如何实现put</span><br><span class="line">- 链表查找和红黑树查找时间复杂度</span><br><span class="line">- spark和hadoop的区别</span><br><span class="line">- TCP的四次挥手问题</span><br><span class="line">- 关于close_wait、time_wait和closing状态了解多少</span><br><span class="line">- redis的client和server通信协议了解么</span><br><span class="line">- mysql中的脏读和幻读的区别</span><br><span class="line">- 单例模式</span><br><span class="line">- 为什么需要使用DCL</span><br><span class="line">- 算法：合并连个有序数组问题</span><br><span class="line">- 算法：链表删除</span><br></pre></td></tr></table></figure><h4 id="二面-5"><a href="#二面-5" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- 项目：ABTest数据架构</span><br><span class="line">- 如何解决spark streaming 使用mysql保存offset时多消费问题</span><br><span class="line">- spark中master、slave、worker、driver的概念区别</span><br><span class="line">- worker和Executor的区别</span><br><span class="line">- spark如何划分job</span><br><span class="line">- spark如何划分stage</span><br><span class="line">- spark如何划分task</span><br><span class="line">- redis的读写性能</span><br><span class="line">- kafka的读写性能</span><br><span class="line">- 说说kafka的架构</span><br><span class="line">- 关于kafka消费partition个数问题</span><br><span class="line">- partition的replica的一致性问题</span><br><span class="line">- low level实现消费者，能不能多个消费一个topic</span><br><span class="line">- kafka的 high level和 low level 的区别</span><br><span class="line">- 算法：字符串判断是不是合法的double类型，eg:+1.e+5、+.12e+3、1、1.0都是true，+e0就不是。</span><br></pre></td></tr></table></figure><p>京东的hr面也是很惊奇，当时我面试时是3对5模式，也就是3个hr同时面试5个候选人，要抢答啊这是？让对比京东快递和菜鸟快递，你自己的知识能对京东的价值等等问题。反正我是吐槽了一把京东模式的弊端，毕竟我那时候是阿里粉，233333……hr面这么怼它后来还很意外的给了offer，令我吃惊。由于薪资太低被我拒绝了，后来hr再来联系说可以申请涨薪也被我给回绝了。</p><h3 id="搜狗"><a href="#搜狗" class="headerlink" title="搜狗"></a>搜狗</h3><h4 id="一面-6"><a href="#一面-6" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 做一套题</span><br><span class="line">- 自我介绍</span><br><span class="line">- 讲讲ocpc的业务相关</span><br><span class="line">- 如何设计一个ABTest平台</span><br><span class="line">- 算法：长20宽2的一块地，长1宽2的砖块，有多少种铺砖的方式</span><br><span class="line">- 算法：手写最小堆排序</span><br></pre></td></tr></table></figure><h4 id="二面-6"><a href="#二面-6" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 关于头条广告系统的架构方面</span><br><span class="line">- 关于CPC、CPM等广告占比</span><br><span class="line">- 了解广告策略相关的什么</span><br><span class="line">- 算法：字符串编辑距离计算，dp问题</span><br></pre></td></tr></table></figure><p>搜狗和搜狐是国内互联网中最轻松的公司了吧，只是给我的offer太低了，而且还是C++/算法工程师。年假还是蛮有诱惑力的，有15天的年假。</p><h3 id="CVTE-1"><a href="#CVTE-1" class="headerlink" title="CVTE"></a>CVTE</h3><p>为啥我又投了CVTE，可能最开始校招比较焦虑，就各种海投。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- 自我介绍</span><br><span class="line">- hadoop任务调度策略？</span><br><span class="line">- hdfs的HA，如何实现？</span><br><span class="line">- active namenode和standby namenode之间如何共享Edits log？</span><br><span class="line">- namenode HA情况下，还需要Secondary namenode么？</span><br><span class="line">- hdfs自身存储文件的格式有哪些</span><br><span class="line">- hdfs副本存放策略</span><br><span class="line">- 假如hdfs client当前不在集群中，副本如何存放？路径远近如何计算？</span><br><span class="line">- spark streaming 如何实现的</span><br><span class="line">- spark sql最后都是解析成map reduce来实现的么？</span><br><span class="line"></span><br><span class="line">- JVM有哪些内存回收算法</span><br><span class="line">- 如何使JVM报StackOverflow错误</span><br><span class="line">- 不使用函数反复调用，如何做</span><br><span class="line">- int[] a = &#123;1,30,100,150&#125;内存中如何分布</span><br><span class="line">- Java能否获取到引用的名称？</span><br></pre></td></tr></table></figure><p></p><p>投的是什么提前批CVTE精英计划，不过后来到hr面挂了，呵呵哒</p><h3 id="网易-1"><a href="#网易-1" class="headerlink" title="网易"></a>网易</h3><p>投递的是网易杭研，8月底去杭州网易总部面试。2面 + hr面。最后竟然挂了，18年网易校招我无力吐槽。好像已经记不得有啥有营养的问题了，不过照样记得一个hr彩蛋，2333333……</p><p>跟实习一样，这里又有一个小插曲。背景：面试了一下午，等到hr面时我着急赶火车回北京。加上8月底我已经有好几个公司都到hr面阶段，所以说话比较随便（还是too naive）。当时hr大姐姐问我为啥会选择网易？我说我比较想去类似头条、网易这类发展型公司，这样自己能力有更大的发挥空间……等等，这时候hr突然说：你觉得网易是跟头条差不多的发展型公司？哎呀，突然觉得气氛哪里不对劲了……</p><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><h4 id="现场笔试"><a href="#现场笔试" class="headerlink" title="现场笔试"></a>现场笔试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- 增加内存为什么使程序运行快？</span><br><span class="line">- 关于计算时间复杂度</span><br><span class="line">- 知乎喝水试毒，最少需要多少人</span><br><span class="line">- 快排时间复杂度问题</span><br></pre></td></tr></table></figure><h4 id="一面-7"><a href="#一面-7" class="headerlink" title="一面"></a>一面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 自我介绍</span><br><span class="line">- 最大连续子数组和</span><br><span class="line">- 最大连续子数组绝对值和</span><br><span class="line">- 证明以上</span><br><span class="line">- 秀了一把循环数组最大连续子数组和</span><br><span class="line">- 一个数组，甲乙分别从前后取数，问谁能赢</span><br><span class="line">- spark 算子问题transfer与action算子</span><br></pre></td></tr></table></figure><h4 id="二面-7"><a href="#二面-7" class="headerlink" title="二面"></a>二面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- 自我介绍</span><br><span class="line">- 设计生产者到server替换kafka满足[可用性]、[低延时]、[高吞吐]</span><br><span class="line">- 如何处理低延时和高吞吐的问题？参考网络层TCP滑动窗口解决方案</span><br><span class="line">- Java单核cpu多线程进行i++是否需要进行同步控制</span><br><span class="line">- 为什么？</span><br><span class="line">- python呢？</span><br><span class="line">- hive处理数据偏移问题</span><br><span class="line">- 聊数据挖掘比赛的事</span><br><span class="line">- 关于提取特征问题</span><br><span class="line">- 笔试上楼梯能否用空间O(1)的算法，时间O(1)的算法？(斐波那契数列的公式</span><br></pre></td></tr></table></figure><h4 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 介绍在头条的项目</span><br><span class="line">- 关于分层实验</span><br><span class="line">- 关于抽样方式</span><br><span class="line">- 你平时喜不喜欢主动探索动手之类的</span><br><span class="line">- 给你offer什么条件下会不来</span><br><span class="line">- 你还有什么问题么</span><br></pre></td></tr></table></figure><p>状态：终面挂。最后一面非技术面了要表现温顺一些，有眼力价，否则就像我一样。</p><h3 id="拼多多"><a href="#拼多多" class="headerlink" title="拼多多"></a>拼多多</h3><p>拼多多的校招流程很长很长……大概7月份就做笔试了，等了一个月忘记了才通知面试消息，然而又等了一个月才通知正式面试。流程时间太长不适合吊死，不过拼多多的面试和hr小姐姐还是可以的，现在还记得hr小姐姐很白很可爱，而且还是武汉大学的。hahaha……</p><p>随便说一下拼多多的待遇吧，包吃包住，一周六天，吓的我都不敢去。要钱又命硬的可以去，嗯！</p><p>最后，对仍奋战校招的哥们儿说一句：加油！！！</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;p&gt;三年之后又三年，三年之后又三年，快十年了老大。《无间道》里的这句话也是我想说的，终于我也要毕业找工作了（正巧又是本命年。这里对从17年3月份开始的春招实习面试，一直到9月份的秋招面试进行回顾总结，其中包括求职历程、面试题目、公司待遇等等方面。想看就点进来吧……&lt;br&gt;
    
    </summary>
    
      <category term="校招" scheme="http://zhangcabbage.cn/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="校招" scheme="http://zhangcabbage.cn/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="面试" scheme="http://zhangcabbage.cn/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>阿里校招回忆录</title>
    <link href="http://zhangcabbage.cn/2017/%E9%98%BF%E9%87%8C%E6%A0%A1%E6%8B%9B-%E6%A2%A6%E6%83%B3%E6%98%AF%E4%B8%80%E5%AE%9A%E8%A6%81%E6%9C%89%E7%9A%84%EF%BC%8C%E4%B8%87%E4%B8%80%E5%AE%9E%E7%8E%B0%E4%BA%86%E5%91%A2.html"/>
    <id>http://zhangcabbage.cn/2017/阿里校招-梦想是一定要有的，万一实现了呢.html</id>
    <published>2017-09-24T07:51:05.000Z</published>
    <updated>2018-01-17T12:46:25.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><p>国内谈互联网必言<strong>BAT</strong> <strong>TMD</strong>(<strong>Baidu、Alibaba、Tencent、TouTiao、MeiTu、DiDi</strong>)，同样这些是IT校招必投公司。本文是自己18年校招阿里面试的回忆录，其中也会谈及一些校招准备。<br><a id="more"></a></p><hr><p>更新历史</p><ul><li>2017.09.24: 完成初稿</li><li>2018.01.17: 修改，删减过多的个人情感表达</li></ul><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>校招是段劳心伤神的经历，从7月中一直到9月底，身心都承受着巨大的压力。大家都迷茫过，怀疑过，失落过… 希望我的经历能给大家一点帮助。我会尽量客观叙述面试过程，多些干货少些扯淡。我有个习惯，每次面试完会立马通过回忆记录下面试问题，以便查缺补漏。下面回忆录也多以直接贴面试问题为主。</p><h2 id="实习面试"><a href="#实习面试" class="headerlink" title="实习面试"></a>实习面试</h2><p>从3月份春招实习开始</p><h3 id="春招内推一面"><a href="#春招内推一面" class="headerlink" title="春招内推一面"></a>春招内推一面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">[项目]</span><br><span class="line">介绍在公司工作内容</span><br><span class="line">[大数据] </span><br><span class="line">日志收集流程 </span><br><span class="line">spark和hadoop的区别 </span><br><span class="line">hadoop如何实现高可用 </span><br><span class="line">zookeeper的作用</span><br><span class="line">[Java基础]</span><br><span class="line">try&#123; return ;&#125;catch()&#123;&#125;finally&#123; return &#125;哪个return会起作用？ </span><br><span class="line">[多线程]</span><br><span class="line">HashMap自己实现的key为什么需要同时实现equals和hashcode </span><br><span class="line">Java中支持同步的集合有哪些 </span><br><span class="line">多线程volatile </span><br><span class="line">volatile保证程序执行顺序，那为啥需要保证，如果不保证先写再读会出现什么问题？ </span><br><span class="line">多线程synchronized </span><br><span class="line">ThreadLocal的作用 </span><br><span class="line">[IO] </span><br><span class="line">关于Java NIO </span><br><span class="line">IO操作时会抛出啥异常 </span><br><span class="line">序列化问题，ID变化会出现什么结果 </span><br><span class="line">是否使用过其他序列化工具 </span><br><span class="line">[JVM] </span><br><span class="line">回收算法有哪些 </span><br><span class="line">新生代老年代 </span><br><span class="line">控制程序内存的参数 </span><br><span class="line">如何看程序哪地方内存溢出</span><br><span class="line">[MySQL] </span><br><span class="line">mysql支持事务么 </span><br><span class="line">事务隔离级别</span><br><span class="line">mysql索引使用什么数据结构</span><br><span class="line">网络协议</span><br><span class="line">Http状态码列举 </span><br><span class="line">Http非状态协议 </span><br><span class="line">cookie的作用，数据存储样式</span><br><span class="line">[操作系统] </span><br><span class="line">Linux下看CPU使用量 </span><br><span class="line">看内存使用量 </span><br><span class="line">看磁盘IO情况 </span><br><span class="line">web服务器有哪些？ </span><br><span class="line">Linux下的epoll是阻塞还是非阻塞？</span><br><span class="line">[算法和数据结构] </span><br><span class="line">1、一亿个数据找其中最大的十个(内存放得下)，我说用快速查找，时间复杂度为O(N)，还怎么优化</span><br><span class="line">2、一亿个电话号码，都是八位每一位都是0-9，内存放不下，可能会有重复。如何找其中不重复电话号码的个数？(压缩算法,可以使用位图)</span><br></pre></td></tr></table></figure><p>1个多小时的面试，由于准备不足，回答的很不好，第二天官网状态就显示挂了。这段时间还有个室友也面了阿里，并最后拿到了阿里云的实习offer。不死心下，又进行了自主投递，这次自主投递就是之后一直面试的<code>阿里中间件数据库部门</code>了。</p><p>大公司不是所有的部门都很好，bat边缘部门还不如tmd核心部门。建议有认识核心部门师兄的同学针对性的投，走官方流程随意分配部门不一定很好。</p><h3 id="春季校招实习一面"><a href="#春季校招实习一面" class="headerlink" title="春季校招实习一面"></a>春季校招实习一面</h3><p>这个时候大概为2017.04.19<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">介绍一下项目</span><br><span class="line">数据是如何采集的？</span><br><span class="line">spark规则模型不可能完全用sql来实现，如果让你实现一个可以接入处理过程的脚本，你会如何实现？</span><br><span class="line">常见的java集合</span><br><span class="line">HashMap的实现，如何处理碰撞？</span><br><span class="line">能否存放null值，null值得hashcode是多少？</span><br><span class="line">如果分别不实现hashcode和equals存放HashMap会出现什么情况？</span><br><span class="line">HashMap和concurrentHashMap的区别。</span><br><span class="line">举个栗子说明HashMap如何操作不安全。</span><br><span class="line">concurrentHashMap如何实现的？</span><br><span class="line">CAS的实现原理？</span><br><span class="line">为什么CAS乐观锁要比同步锁这种方式好</span><br><span class="line">如何避免CAS的循环等待？</span><br><span class="line">volatile和AtomicInteger的区别，或者你可以先说说它们分别的作用，再说说他们的区别。 </span><br><span class="line">synchronized和显示锁的区别</span><br></pre></td></tr></table></figure><p></p><h3 id="春季校招实习二面"><a href="#春季校招实习二面" class="headerlink" title="春季校招实习二面"></a>春季校招实习二面</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">spark如何实现top5</span><br><span class="line">spark如何实现求avg</span><br><span class="line">spark master节点fail该如何实现转移</span><br><span class="line">checkpoint动态的备份task和中间结果到hdfs，会影响spark的性能，那么应该如何解决这个问题？</span><br><span class="line">kafka为什么作为消息队列存取数据很快？</span><br><span class="line">zerocopy的概念</span><br><span class="line">关于spark、kafka方面你自己还了解多少，讲讲</span><br><span class="line">treeMap内部实现</span><br><span class="line">linkedHashMap内部实现</span><br><span class="line">treeMap和linkedHashMap它们之间插入、删除、查找的时间复杂度</span><br><span class="line">concurrentHashMap的内部实现</span><br><span class="line">关于mysql和nosql了解多少</span><br><span class="line">redis了解多少，讲讲其备份过程</span><br><span class="line">关于负载均衡了解多少</span><br></pre></td></tr></table></figure><h3 id="春季校招实习三面"><a href="#春季校招实习三面" class="headerlink" title="春季校招实习三面"></a>春季校招实习三面</h3><p>三面有点尬，直接问我有没有看过spark、kafka的源码，没有的话，咱们就直接做两道算法题吧。两道比较简单的算法题，做完邮件回发，从此没有消息。这个时候为2017.05.05</p><h3 id="面试中"><a href="#面试中" class="headerlink" title="面试中"></a>面试中</h3><p>从实习三面后官网状态一直是面试中，持续到校招，自动由实习招聘跳转成应届校招，状态仍是面试中，大概就是传说中的默拒了吧。后来在byr论坛找学长校招内推，也一直没有消息。</p><p>8月中旬的那段时间一直收到阿里让做测评和笔试的短信，当时已经没有校招内推面试机会了，索性自暴自弃，拒绝做测评和笔试。后来收到过一次阿里电话，然而没 接 到！因为新换的小米6震动声音小，没有接到电话。这期间另外一个室友已经部门内推和校招内推面了2次阿里，跟我说阿里接不到电话就再也不会打电话了…弃疗…</p><h2 id="校招面试"><a href="#校招面试" class="headerlink" title="校招面试"></a>校招面试</h2><p>08.24，突然又收到阿里电话，然而因为之前一直在实习，8月中旬时候一直没有面试，完全就是一直弱鸡啊，怎么面试。。。</p><p>仓促的进行面试，抱着放弃的心态问了一下面试官，我的奇怪状态。面试官告诉我，面试进度紧接着实习面试记录，目前是三面。what？黑人问号脸…</p><h3 id="秋季校招一面-三面？"><a href="#秋季校招一面-三面？" class="headerlink" title="秋季校招一面(三面？)"></a>秋季校招一面(三面？)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">讲讲实习项目</span><br><span class="line">头条集群多大，你有没有参与管理集群</span><br><span class="line">你对什么比较熟悉kafka？redis?</span><br><span class="line">kafka如何实现一致性</span><br><span class="line">ISR如何实现？</span><br><span class="line">具体如何解释follower跟得上leader？具体实现</span><br><span class="line">一道算法题：给两个文件A、B分别100G，内存1G，AB两个文件分别一行存放一个long型数据，求AB两个文件共有的数据的出现频率前十的数</span><br></pre></td></tr></table></figure><h3 id="秋季校招交叉"><a href="#秋季校招交叉" class="headerlink" title="秋季校招交叉"></a>秋季校招交叉</h3><p>25号，头条转正答辩。在公司接到了阿里交叉面的电话。同样问了些大数据、Java基础、多线程、linux相关、毕业论文相关。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Feature的作用</span><br><span class="line">生产者消费者模式的实现</span><br><span class="line">如何了解这些Java知识的</span><br><span class="line">如何看待数据分析和数据平台两种工作方向的？</span><br><span class="line">阻塞队列里的condition的实现</span><br><span class="line">有没有在开源社区提交过pull</span><br><span class="line">对linux bash脚本了解如何？</span><br><span class="line">如果有个文件让你统计有多少行，怎么统计？wc -l</span><br></pre></td></tr></table></figure><p></p><h3 id="秋季校招HR面"><a href="#秋季校招HR面" class="headerlink" title="秋季校招HR面"></a>秋季校招HR面</h3><p>效率很快，下午交叉面面完，一会儿就收到hr电话，约晚上进行视频面。没想到我也能面到阿里hr面。</p><h3 id="面试中-1"><a href="#面试中-1" class="headerlink" title="面试中"></a>面试中</h3><blockquote><p>不是你不优秀，只是你不够优秀</p></blockquote><p>之后的状态又一直是<strong>面试中</strong>，9月8号的样子特地发邮件问了实习三面面试官，面试官回邮件说：希望很大，你再等等，两周内有消息。之后阿里各部门的意向书都相继发下来，让我更加焦虑，每天刷牛客、QQ群看大家状态，打听消息。嗯，其他部门的offer已经陆续发完了……</p><p>结果终究还是来了，9月13号的样子，再一次收到阿里部门电话。</p><blockquote><p>告诉我说: 部门原本4个hc(校招名额)，你是其中一个，但是现在被砍到2个。我们不得已进行横纵向比较，非常遗憾的通知你，这次不给你发offer了。部门老大也表示很遗憾，说是要加微信，长线联系观察，说不定明年有机会在合作……</p></blockquote><p>真是印证了头条的一位同事跟我说的话：<code>不是你不优秀，只是你不够优秀</code>。按阿里的话：<code>拥抱变化</code>。。。我成为了终面小杀手，<strong>第四范式</strong>、<strong>阿里</strong>、<strong>网易</strong>都是技术面过了，到hr面不知道什么情况挂了。</p><h2 id="阿里offer"><a href="#阿里offer" class="headerlink" title="阿里offer"></a>阿里offer</h2><p>期间还问了加我微信的阿里师兄我的面试评级，他告诉我是a，还说如果按照平时流程已经ok了，可惜了。失落、迷茫感剧增。</p><p>9月22号，突然收到阿里短信，说欢迎亲加入阿里巴巴。what？黑人问号一脸懵逼。。。赶紧找之前说跟我保持联系的阿里师兄确认，最后说是别的部门从中间件部门溢出名单中捞起来了，简直是电影桥段般的逆转。</p><p>从16年开始到今天，<code>3次rejected，2年的期盼，1心追求</code>。一路曲曲折折。我，还是拿到了阿里offer。<br><img src="/images/summary_17/ali1.png" alt="岗位申请历程" title="岗位申请历程"></p><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><ul><li>自己的定位很重要！前端、后台、移动端、算法、大数据，千万不要反复变</li><li>实习要找合适的。方向和公司双赢最好</li><li>早做准备！如果不想留实习公司，早辞职。</li><li>调整好心态，心态！</li><li>不要害怕失败，早晚会成功。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;p&gt;国内谈互联网必言&lt;strong&gt;BAT&lt;/strong&gt; &lt;strong&gt;TMD&lt;/strong&gt;(&lt;strong&gt;Baidu、Alibaba、Tencent、TouTiao、MeiTu、DiDi&lt;/strong&gt;)，同样这些是IT校招必投公司。本文是自己18年校招阿里面试的回忆录，其中也会谈及一些校招准备。&lt;br&gt;
    
    </summary>
    
      <category term="校招" scheme="http://zhangcabbage.cn/categories/%E6%A0%A1%E6%8B%9B/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="校招" scheme="http://zhangcabbage.cn/tags/%E6%A0%A1%E6%8B%9B/"/>
    
      <category term="阿里" scheme="http://zhangcabbage.cn/tags/%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
  <entry>
    <title>Permutation --- 字符串的排列</title>
    <link href="http://zhangcabbage.cn/2017/Permutation-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97.html"/>
    <id>http://zhangcabbage.cn/2017/Permutation-字符串的排列.html</id>
    <published>2017-07-15T08:50:43.000Z</published>
    <updated>2017-07-15T09:34:12.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>犯过的错误，我总是会反复再犯。<code>Permutation</code> – 字符串的排列，16年遇到这个问题，特地在code中总结，然而过了一年没怎么刷题的我，又有一点混。下面对解法做概要记录</p><p>直接给题目</p><p>输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串<code>abc</code>, 则打印出由字符<code>a,b,c</code>所能排列出来的所有字符串: <code>abc</code>,<code>acb</code>,<code>bac</code>,<code>bca</code>,<code>cab</code>和<code>cba</code>。可能有字符重复！</p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h3 id="解法一-递归"><a href="#解法一-递归" class="headerlink" title="解法一 递归"></a>解法一 递归</h3><p>把字符串看成两部分：第一个字符和剩下字符，每次从剩下字符中选择一个作为头字符，之后递归进行。</p><p>简单如上说，可能你不知道如何code，我们来分析一下关键点。<br>1）关于头字符的选择。<br>对于一个<code>str(i,j)</code>的字符，我们从<code>i</code>到<code>j</code>循环轮流作为头字符。这里有个问题：可能字符串有重复。对字符<code>aba</code>，按之前的分析，<code>a</code>就会当两次老大，但是这就不公平了啊。<code>b</code>(小妾)就会想凭什么<code>a</code>(正房)被临幸两次，我才一次，嘤嘤嘤……(老婆：什么…你还想有小妾？逃…..)所以需要控制一下频率，怎么回事，我说话语气怎么不对了，咳咳。。<br>在临幸到下标<code>x</code>时，那么就在<code>str(i, x-1)</code>查看有没有被临幸过，如果没有则今晚就翻它的牌子。</p><p>2）递归的结束点<br>我们需要一个递归传递当前字符遍历下标，当下标到字符串结尾时，则停止。</p><p>其实很简单，code如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    if (str == null || &quot;&quot;.equals(str)) return res;</span><br><span class="line">    char[] c = str.toCharArray();</span><br><span class="line">    permutation(c, 0, res);</span><br><span class="line">    </span><br><span class="line">    Collections.sort(res);  //字典序排列</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void permutation(char[] c, int x, ArrayList&lt;String&gt; res) &#123;</span><br><span class="line">    if (x == c.length) res.add(String.valueOf(c));</span><br><span class="line">    else &#123;</span><br><span class="line">        for (int i = x; i &lt; c.length; i++) &#123;</span><br><span class="line">            if (canSwap(c, x, i)) &#123;  //控制是否交换</span><br><span class="line">                swap(c, x, i);</span><br><span class="line">                permutation(c, x + 1, res);</span><br><span class="line">                swap(c, x, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean canSwap(char[] c, int i, int j) &#123;</span><br><span class="line">    char tmp = c[j];</span><br><span class="line">    for (int k = i; k &lt; j; k++) &#123;</span><br><span class="line">        if (c[k] == tmp) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(char[] nums, int m, int n) &#123;</span><br><span class="line">    char temp = nums[m];</span><br><span class="line">    nums[m] = nums[n];</span><br><span class="line">    nums[n] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="解法二-循环"><a href="#解法二-循环" class="headerlink" title="解法二 循环"></a>解法二 循环</h3><p>如下我们有规律的循环遍历，直接产生一个字典序列的排列集。</p><p>算法过程描述如下：<br>1）从后往前，找到第一个顺序前后数对，如34126543中的26，2即为替换数a<br>2）从后往前，找到第一个比替换数a大的最小数，很容易知道a之后的数据都是倒序，所以从后往前找第一个比a大的，即比a大的最小数b<br>3）交换此两个数a、b，根据上面的道理我们知道：交换之后a之后的仍为倒序<br>4）把a之后的倒序倒置一遍，即变换为顺序。并返回true</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public ArrayList&lt;String&gt; Permutation(String str) &#123;</span><br><span class="line">    ArrayList&lt;String&gt; res = new ArrayList&lt;String&gt;();</span><br><span class="line">    if (str == null || &quot;&quot;.equals(str)) return res;</span><br><span class="line"></span><br><span class="line">    char[] c = str.toCharArray();</span><br><span class="line">    Arrays.sort(c);</span><br><span class="line">    do &#123;</span><br><span class="line">        res.add(String.valueOf(c));</span><br><span class="line">    &#125; while (hasNextPermutation(c));</span><br><span class="line"></span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean hasNextPermutation(char[] c) &#123;</span><br><span class="line">    int x = c.length;</span><br><span class="line">    while (x &gt; 1) &#123;  //注意：排除 &lt; 2的不需排序字符串</span><br><span class="line">        x--;</span><br><span class="line">        if (c[x - 1] &lt; c[x]) &#123;  //注意：只能是小于</span><br><span class="line">            int y = c.length - 1;</span><br><span class="line">            while (c[y] &lt;= c[x - 1]) y--;  //注意：只能一直到大于 c[x - 1] 的数</span><br><span class="line">            swap(c, x - 1, y);</span><br><span class="line">            reverse(c, x, c.length - 1);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    reverse(c, 0, c.length - 1);</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(char[] nums, int m, int n) &#123;</span><br><span class="line">    char temp = nums[m];</span><br><span class="line">    nums[m] = nums[n];</span><br><span class="line">    nums[n] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reverse(char[] array, int start, int end) &#123;</span><br><span class="line">    int i = start, j = end;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">        swap(array, i++, j--);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>同样是上面的排序，选出m个做全排列。</p><p>程序该如何？PS: 写其实只需要稍微改一下上面的代码就行。</p><p>具体代码见：<a href="https://github.com/zhangCabbage/modelUtil/blob/master/NumberTheory/Permutation.java" target="_blank" rel="noopener">Permutation</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;犯过的错误，我总是会反复再犯。&lt;code&gt;Permutation&lt;/code&gt; – 字符串的排列，16年遇到这个问题，特地在code中总结，然而过了一年没怎么刷题的我，又有一点混。下面对解法做概要记录&lt;/p&gt;&lt;p&gt;直接给题目&lt;/p&gt;&lt;p&gt;输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串&lt;code&gt;abc&lt;/code&gt;, 则打印出由字符&lt;code&gt;a,b,c&lt;/code&gt;所能排列出来的所有字符串: &lt;code&gt;abc&lt;/code&gt;,&lt;code&gt;acb&lt;/code&gt;,&lt;code&gt;bac&lt;/code&gt;,&lt;code&gt;bca&lt;/code&gt;,&lt;code&gt;cab&lt;/code&gt;和&lt;code&gt;cba&lt;/code&gt;。可能有字符重复！&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://zhangcabbage.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://zhangcabbage.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Permutation" scheme="http://zhangcabbage.cn/tags/Permutation/"/>
    
  </entry>
  
  <entry>
    <title>常见linux命令随记</title>
    <link href="http://zhangcabbage.cn/2017/%E5%B8%B8%E8%A7%81linux%E5%91%BD%E4%BB%A4%E9%9A%8F%E8%AE%B0.html"/>
    <id>http://zhangcabbage.cn/2017/常见linux命令随记.html</id>
    <published>2017-07-07T14:11:03.000Z</published>
    <updated>2018-01-17T15:20:21.350Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h2><p>linux命令以多练习方能熟练，所以本文主要以常见的一些linux查询场景为例，记录常见linux命令的使用。说明：以下示例命令为在mac os上测试ok</p><p><strong>词频统计</strong><br>给一个文件<code>words.txt</code>，内容如下所示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">the day is sunny the the</span><br><span class="line">the sunny is is</span><br></pre></td></tr></table></figure><p></p><p>统计单词出现的频率，并按照词频倒序排列。要求输出如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">the 4</span><br><span class="line">is 3</span><br><span class="line">sunny 2</span><br><span class="line">day 1</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h2 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat words.txt | tr -s &apos; &apos; &apos;\n&apos; | sort | uniq -c | sort -r | awk &apos;&#123; print $2, $1 &#125;&apos;</span><br></pre></td></tr></table></figure><p>这里大致说下以上命令的使用：</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>tr意为 translate，用来进行字符进行替换、压缩和删除。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-d delete 删除</span><br><span class="line">-s squeeze 压缩</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">&gt; echo &apos;HELLO WORLD&apos; | tr &apos;A-Z&apos; &apos;a-z&apos;</span><br><span class="line">&gt; hello world</span><br><span class="line"></span><br><span class="line">&gt; echo &apos;hello    world!&apos; | tr -s &apos; &apos; &apos; &apos;</span><br><span class="line">&gt; hello world!</span><br><span class="line">第一个为原字符集，第二个为替换成的目标字符集</span><br></pre></td></tr></table></figure><p></p><p>参考：<a href="http://man.linuxde.net/tr" target="_blank" rel="noopener">tr命令</a></p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>sort顾名思义排序<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-r reverse 反转</span><br><span class="line">-u unique 不同</span><br></pre></td></tr></table></figure><p></p><p>参考：<a href="http://man.linuxde.net/sort" target="_blank" rel="noopener">sort命令</a></p><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>通常和sort一起使用<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-c count 记录重复个数</span><br><span class="line"></span><br><span class="line">eg: 对文件words.txt          the</span><br><span class="line">                            day</span><br><span class="line">                            is</span><br><span class="line">                            sunny</span><br><span class="line">                            the</span><br><span class="line">                            the</span><br><span class="line">                            sunny</span><br><span class="line">                            is</span><br><span class="line">                            is</span><br><span class="line"></span><br><span class="line">&gt; cat words.txt | uniq</span><br><span class="line">&gt; the</span><br><span class="line">  day</span><br><span class="line">  is</span><br><span class="line">  sunny</span><br><span class="line">  the</span><br><span class="line">  sunny</span><br><span class="line">  is</span><br><span class="line">可以看到直接用unqi还是会有重复的，所以才会和sort配合使用</span><br></pre></td></tr></table></figure><p></p><p>参考：<a href="http://man.linuxde.net/uniq" target="_blank" rel="noopener">uniq命令</a></p><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-E  --extended-regexp  #将样式为延伸的普通表示法来使用</span><br><span class="line">-f &lt;规则文件&gt;  --file=&lt;规则文件&gt;  #指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式</span><br><span class="line">-n  --line-number  #在显示符合样式的那一行之前，标示出该行的列数编号</span><br><span class="line">-c  --count  #计算符合样式的列数</span><br></pre></td></tr></table></figure><p></p><p>下面举例说明使用方法<br>过滤一个文件中的有效电话号码，有效电话号码格式为：<br><code>(xxx) xxx-xxxx</code> or <code>xxx-xxx-xxxx</code>，x为数字<br>现有一个文件file.txt为<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">987-123-4567</span><br><span class="line">123 456 7890</span><br><span class="line">(123) 456-7890</span><br></pre></td></tr></table></figure><p></p><p><strong>方法一 ———- [-E]</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-E 使用扩展的正常的正则表达式过滤</span><br><span class="line">grep -E &apos;^\(\d&#123;3&#125;\) \d&#123;3&#125;-\d&#123;4&#125;$&apos; file.txt</span><br><span class="line">or</span><br><span class="line">cat file.txt | grep -E &apos;^(\(\d&#123;3&#125;\) |\d&#123;3&#125;-)\d&#123;3&#125;-\d&#123;4&#125;$&apos;</span><br></pre></td></tr></table></figure><p></p><p><strong>方法二 ———- [-f]</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">写一个规则文件pattern.txt:</span><br><span class="line">^\d\&#123;3\&#125;-\d\&#123;3\&#125;-\d\&#123;4\&#125;$</span><br><span class="line">^(\d\&#123;3\&#125;) \d\&#123;3\&#125;-\d\&#123;4\&#125;$</span><br><span class="line"></span><br><span class="line">筛选命令为：</span><br><span class="line">grep file.txt -nf pattern.txt</span><br><span class="line">or</span><br><span class="line">grep file.txt -cf pattern.txt</span><br></pre></td></tr></table></figure><p></p><p>参考：<a href="http://www.cnblogs.com/peida/archive/2012/12/17/2821195.html" target="_blank" rel="noopener">每天一个linux命令（39）：grep 命令</a></p><h3 id="awk"><a href="#awk" class="headerlink" title="awk"></a>awk</h3><p>使用方法：<br><code>awk &#39;{pattern + action}&#39; filenames</code><br>eg:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat file.txt | awk &apos;BEGIN &#123;print &quot;Begin!&quot;&#125;  &#123;print $1&#125; END &#123;print &quot;End!&quot;&#125;&apos;</span><br><span class="line">awk工作流程：</span><br><span class="line">先执行BEGING，然后读取文件，读入有/n换行符分割的一条记录，然后将记录按指定的域分隔符划分域，填充域，</span><br><span class="line">$0则表示所有域,$1表示第一个域,$n表示第n个域,随后开始执行模式所对应的动作action。接着开始读入第二条记录······</span><br><span class="line">直到所有的记录都读完，最后执行END操作。</span><br><span class="line"></span><br><span class="line">常见内置变量</span><br><span class="line">NF        浏览记录的域的个数</span><br><span class="line">NR        已读的记录数</span><br></pre></td></tr></table></figure><p></p><p>示例：<br>对一个文件file.txt，其内容为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name age</span><br><span class="line">alice 21</span><br><span class="line">ryan 30</span><br></pre></td></tr></table></figure><p></p><p>需要把它转化为如下形式 (相当于矩阵的反转)：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name alice ryan</span><br><span class="line">age 21 30</span><br></pre></td></tr></table></figure><p></p><p>给出示例代码为：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">awk &apos;</span><br><span class="line">&#123;</span><br><span class="line">    for (i = 1; i &lt;= NF; i++) &#123;</span><br><span class="line">        if(NR == 1) &#123;</span><br><span class="line">            s[i] = $i;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            s[i] = s[i] &quot; &quot; $i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">END &#123;</span><br><span class="line">    for (i = 1; s[i] != &quot;&quot;; i++) &#123;</span><br><span class="line">        print s[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;&apos; file.txt</span><br></pre></td></tr></table></figure><p></p><p>参考：<a href="http://www.cnblogs.com/ggjucheng/archive/2013/01/13/2858470.html" target="_blank" rel="noopener">linux awk命令详解</a></p><h2 id="其他小菜"><a href="#其他小菜" class="headerlink" title="其他小菜"></a>其他小菜</h2><p><strong>1、统计某一目录下文件数目</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l | wc -l</span><br></pre></td></tr></table></figure><p></p><p>参考链接：<a href="http://www.cnblogs.com/peida/archive/2012/12/18/2822758.html" target="_blank" rel="noopener">每天一个linux命令（40）：wc命令</a></p><p><strong>2、统计某一目录下普通文件个数</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ls -l | grep &apos;^-&apos; | wc -l</span><br><span class="line"></span><br><span class="line">ls -l 结果如下：</span><br><span class="line">-rw-r--r--    1 zhang_zack  staff   174  7  7 22:11 db.json</span><br><span class="line">drwxr-xr-x  291 zhang_zack  staff  9894  2 22 19:37 node_modules</span><br><span class="line">第一个d表示是否为文件夹</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;开胃菜&quot;&gt;&lt;a href=&quot;#开胃菜&quot; class=&quot;headerlink&quot; title=&quot;开胃菜&quot;&gt;&lt;/a&gt;开胃菜&lt;/h2&gt;&lt;p&gt;linux命令以多练习方能熟练，所以本文主要以常见的一些linux查询场景为例，记录常见linux命令的使用。说明：以下示例命令为在mac os上测试ok&lt;/p&gt;&lt;p&gt;&lt;strong&gt;词频统计&lt;/strong&gt;&lt;br&gt;给一个文件&lt;code&gt;words.txt&lt;/code&gt;，内容如下所示：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;the day is sunny the the&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;the sunny is is&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;统计单词出现的频率，并按照词频倒序排列。要求输出如下：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;the 4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;is 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sunny 2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;day 1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="http://zhangcabbage.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://zhangcabbage.cn/tags/linux/"/>
    
      <category term="命令行" scheme="http://zhangcabbage.cn/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C/"/>
    
  </entry>
  
  <entry>
    <title>hexo定制打赏功能</title>
    <link href="http://zhangcabbage.cn/2017/hexo%E5%AE%9A%E5%88%B6%E6%89%93%E8%B5%8F%E5%8A%9F%E8%83%BD.html"/>
    <id>http://zhangcabbage.cn/2017/hexo定制打赏功能.html</id>
    <published>2017-06-10T14:00:56.000Z</published>
    <updated>2017-06-10T16:04:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="定制hexo样式"><a href="#定制hexo样式" class="headerlink" title="定制hexo样式"></a>定制hexo样式</h2><p>个人博客采用<code>hexo</code>依托<code>github</code>搭建，采用简洁美观的<code>next</code>主题。打开<code>[打赏]</code>功能后，对<code>[赏]</code>字按钮样式一直耿耿于怀。</p><a id="more"></a><p>打开<code>[打赏]</code>，默认的样式如下：<br><img src="/images/technology/before_shang.png" alt=""></p><p>见过一个圆形<code>[赏]</code>样式之后，从此美观强迫症停不下来！样式如下：<br><img src="/images/technology/after_shang.png" alt=""></p><p>如何修改呢？</p><p>在<code>hexo/themes/next/layout/_macro/reward.swig</code>文件中，我们看到[打赏]功能的主要界面代码。</p><p>自定义如下标签样式<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span&gt;赏&lt;/span&gt;</span><br></pre></td></tr></table></figure><p></p><p>↓↓↓<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span onmouseover=&quot;this.style.color=&apos;rgb(236,96,0)&apos;;this.style.background=&apos;rgb(204,204,204)&apos;&quot; onmouseout=&quot;this.style.color=&apos;#fff&apos;;this.style.background=&apos;rgb(236,96,0)&apos;&quot; style=&quot;display: inline-block; width: 70px; height: 70px; border-radius: 100%; color: rgb(255, 255, 255); font-style: normal; font-variant: normal; font-weight: 400; font-stretch: normal; font-size: 35px; line-height: 75px; font-family: microsofty; background: rgb(236, 96, 0);&quot;&gt;赏&lt;/span&gt;</span><br></pre></td></tr></table></figure><p></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p><a href="https://github.com/iissnan/hexo-theme-next/issues/1143" target="_blank" rel="noopener">打赏按钮· Issue #1143</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;定制hexo样式&quot;&gt;&lt;a href=&quot;#定制hexo样式&quot; class=&quot;headerlink&quot; title=&quot;定制hexo样式&quot;&gt;&lt;/a&gt;定制hexo样式&lt;/h2&gt;&lt;p&gt;个人博客采用&lt;code&gt;hexo&lt;/code&gt;依托&lt;code&gt;github&lt;/code&gt;搭建，采用简洁美观的&lt;code&gt;next&lt;/code&gt;主题。打开&lt;code&gt;[打赏]&lt;/code&gt;功能后，对&lt;code&gt;[赏]&lt;/code&gt;字按钮样式一直耿耿于怀。&lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://zhangcabbage.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zhangcabbage.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="博客技术" scheme="http://zhangcabbage.cn/tags/%E5%8D%9A%E5%AE%A2%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>偶遇mysql group_concat与find_in_set函数</title>
    <link href="http://zhangcabbage.cn/2017/%E5%81%B6%E9%81%87mysql-group-concat%E4%B8%8Efind-in-set%E5%87%BD%E6%95%B0.html"/>
    <id>http://zhangcabbage.cn/2017/偶遇mysql-group-concat与find-in-set函数.html</id>
    <published>2017-06-08T14:19:33.000Z</published>
    <updated>2017-06-10T02:57:00.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="偶遇需求"><a href="#偶遇需求" class="headerlink" title="偶遇需求"></a>偶遇需求</h2><p>逛论坛，偶然看到下面这个问题，因为最近一直在写<code>Hive SQL</code>，就意起试图解决(装b，逃…)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">device、order2张表。</span><br><span class="line">每完成一个订单，会插入数据到order表里，记录一些数据，包括device_id,时间，状态（已支付）等……（没有订单就不插入数据到order表）</span><br><span class="line">device 表里面就是一些设备信息。</span><br><span class="line"></span><br><span class="line">需要的结果是：</span><br><span class="line">展示（一段时间内），每一天，有哪些设备没有订单；</span><br><span class="line"></span><br><span class="line">举栗子：</span><br><span class="line"></span><br><span class="line">今天设备 abc 没有订单 昨天bd没有订单</span><br><span class="line">2017-06-08 a,b,c</span><br><span class="line">2017-06-07 b,d</span><br></pre></td></tr></table></figure><p>思考一下，试试…<br><a id="more"></a></p><h2 id="探索"><a href="#探索" class="headerlink" title="探索"></a>探索</h2><p>首先，我们新建两个表，来进行之后的尝试。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">device</span><br><span class="line">+-----------+</span><br><span class="line">| device_id |</span><br><span class="line">+-----------+</span><br><span class="line">|     1     |</span><br><span class="line">|     2     |</span><br><span class="line">|     3     |</span><br><span class="line">|     4     |</span><br><span class="line">|     5     |</span><br><span class="line">+-----------+</span><br><span class="line"></span><br><span class="line">order</span><br><span class="line">+---------------------+----------+-----------+</span><br><span class="line">|      time           | order_id | device_id |</span><br><span class="line">+---------------------+----------+-----------+</span><br><span class="line">| 2017-06-08 00:00:00 |     1    |     1     |</span><br><span class="line">| 2017-06-08 00:00:00 |     2    |     2     |</span><br><span class="line">| 2017-06-07 00:00:00 |     3    |     1     |</span><br><span class="line">+---------------------+----------+-----------+</span><br></pre></td></tr></table></figure><p></p><p>要找没有订单的设备，条件是device表中不在日订单中。我们试图以<code>time</code>来进行<code>group by</code>，并尝试合成每组的<code>device_id</code>。通过查找mysql聚合函数，被我查到<a href="https://dev.mysql.com/doc/refman/5.7/en/group-by-functions.html#function_group-concat" target="_blank" rel="noopener"><code>group_concat</code></a>。</p><p>虽然不知道对之后有没有帮助，我们先了解一下其效果，如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">select time, GROUP_CONCAT(device_id) as device_list</span><br><span class="line">from order</span><br><span class="line">group by time;</span><br><span class="line"></span><br><span class="line">结果如下:</span><br><span class="line">+---------------------+--------------------+</span><br><span class="line">|      time           |    device_list     |</span><br><span class="line">+---------------------+--------------------+</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |</span><br><span class="line">+---------------------+--------------------+</span><br></pre></td></tr></table></figure><p></p><p>其次，我们如何找出所有设备中当天没有订单的设备呢？组合<code>group_concat</code>之后的表与<code>device</code>表，我们知道<code>from a, b</code>如果不使用<code>join on</code>语句，即为两表的笛卡尔积。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">select *</span><br><span class="line">from </span><br><span class="line">(</span><br><span class="line">    select time, GROUP_CONCAT(device_id) as device_list</span><br><span class="line">    from order</span><br><span class="line">    group by time</span><br><span class="line">)a, device</span><br><span class="line">order by time;</span><br><span class="line"></span><br><span class="line">+---------------------+--------------------+-------------+</span><br><span class="line">|      time           |    device_list     |  device_id  |</span><br><span class="line">+---------------------+--------------------+-------------+</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |      1      |</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |      2      |</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |      3      |</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |      4      |</span><br><span class="line">| 2017-06-07 00:00:00 |        1           |      5      |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |      1      |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |      2      |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |      3      |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |      4      |</span><br><span class="line">| 2017-06-08 00:00:00 |        1,2         |      5      |</span><br><span class="line">+---------------------+--------------------+-------------+</span><br></pre></td></tr></table></figure><p></p><p>之后，如果去过滤取得<code>device_id not in group_concat_list</code>。很可惜，<code>group_concat</code>返回的是string_list。不过幸运的是，mysql函数中提供了一个解决函数<a href="https://dev.mysql.com/doc/refman/5.7/en/string-functions.html#function_find-in-set" target="_blank" rel="noopener"><code>find_in_set</code></a>。<br>效果如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT FIND_IN_SET(&apos;b&apos;,&apos;a,b,c,d&apos;);</span><br><span class="line">&gt; 2</span><br></pre></td></tr></table></figure><p></p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过上面的探索，我们最终尝试出最终可以的解决方案如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">select time, GROUP_CONCAT(device_id) as device_list</span><br><span class="line">from (</span><br><span class="line">    select time, GROUP_CONCAT(device_id) as device_list</span><br><span class="line">    from order</span><br><span class="line">    group by time</span><br><span class="line">)tmp, device</span><br><span class="line">where FIND_IN_SET(device_id, device_list) = 0</span><br><span class="line">group by time;</span><br><span class="line"></span><br><span class="line">结果如下：</span><br><span class="line">+---------------------+--------------------+</span><br><span class="line">|      time           |    device_list     |</span><br><span class="line">+---------------------+--------------------+</span><br><span class="line">| 2017-06-07 00:00:00 |     2,3,4,5        |</span><br><span class="line">| 2017-06-08 00:00:00 |     3,4,5          |</span><br><span class="line">+---------------------+--------------------+</span><br></pre></td></tr></table></figure><p></p><p>水一篇博客，赶紧滚去写论文去惹…</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;偶遇需求&quot;&gt;&lt;a href=&quot;#偶遇需求&quot; class=&quot;headerlink&quot; title=&quot;偶遇需求&quot;&gt;&lt;/a&gt;偶遇需求&lt;/h2&gt;&lt;p&gt;逛论坛，偶然看到下面这个问题，因为最近一直在写&lt;code&gt;Hive SQL&lt;/code&gt;，就意起试图解决(装b，逃…)&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;device、order2张表。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;每完成一个订单，会插入数据到order表里，记录一些数据，包括device_id,时间，状态（已支付）等……（没有订单就不插入数据到order表）&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;device 表里面就是一些设备信息。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;需要的结果是：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;展示（一段时间内），每一天，有哪些设备没有订单；&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;举栗子：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;今天设备 abc 没有订单 昨天bd没有订单&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2017-06-08 a,b,c&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2017-06-07 b,d&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;思考一下，试试…&lt;br&gt;
    
    </summary>
    
      <category term="Mysql" scheme="http://zhangcabbage.cn/categories/Mysql/"/>
    
    
      <category term="mysql" scheme="http://zhangcabbage.cn/tags/mysql/"/>
    
      <category term="SQL" scheme="http://zhangcabbage.cn/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>sublime插件开发 -- CabbageFileDiff</title>
    <link href="http://zhangcabbage.cn/2017/sublime%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91-CabbageFileDiff.html"/>
    <id>http://zhangcabbage.cn/2017/sublime插件开发-CabbageFileDiff.html</id>
    <published>2017-05-21T14:33:24.000Z</published>
    <updated>2017-05-22T13:46:20.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="需求来了"><a href="#需求来了" class="headerlink" title="需求来了"></a>需求来了</h2><p>最近总是需要review旧的业务代码进行重构，这个过程中涉及不少sql字段的比较。可类比比较两个无序字符串数组的异同，跟普通的<code>filediff</code>需求略微不同。虽然可以写一个脚本来处理，但是这样每次都需要对比较的字段新建文件。而通常的应用场景是想直接把内容复制到<code>sublime view</code>缓存中进行比较，而不需要新建文件。</p><p>我试图寻找此需求的sublime插件：<a href="https://packagecontrol.io/packages/FileDiffs" target="_blank" rel="noopener"><code>FileDiffs</code></a>、<a href="https://packagecontrol.io/packages/Compare%20Side-By-Side" target="_blank" rel="noopener"><code>Compare Side-By-Side</code></a>等，由于无法进行无序比较，效果都不是很好。之后尝试接入sublime plugin API，参考<code>FileDiffs</code>的展示效果，做个简易的适合自己需求的小插件<code>Cabbage File Diff</code>。<br><a id="more"></a></p><h2 id="开发之前"><a href="#开发之前" class="headerlink" title="开发之前"></a>开发之前</h2><p>Sublime插件开发使用<code>python</code>语言(我假设读者已经熟练掌握python：)，笔者使用的sublime版本为：Sublime Text3。值得一提的是<strong>Sublime Text3基于Python3</strong>（Sublime Text2基于Python2，据作者猜测）。之前一直把Sublime Text仅仅作为一个编辑器，现在才惊觉这货简直就是一个Python交互式shell啊！<code>ctrl + 反单引号</code>打开sublime命令行交互界面，输入<code>print(&quot;Hello World!&quot;)</code>一个新世界的大门打开。</p><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><p>关于Sublime插件的开发，网上已经有不少很好的教程。尽管如此，为了阅读流畅性以及更通俗易懂的引导大家(请开始你的表演)…</p><p>打开Sublime，在菜单栏选择<code>Tools</code>&gt;<code>Developer</code>&gt;<code>New Plugin...</code>，编辑文件如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import sublime</span><br><span class="line">import sublime_plugin</span><br><span class="line"></span><br><span class="line">class ExampleCommand(sublime_plugin.TextCommand):</span><br><span class="line">    def run(self, edit):</span><br><span class="line">        self.view.insert(edit, 0, &quot;Hello, World!&quot;)</span><br></pre></td></tr></table></figure><p></p><p>保存文件为任意文件名.py至Packages文件夹下，关于sublime插件API的继承接口<code>sublime_plugin.TextCommand</code>问题，之后再进行描述。关于类名问题，名称最后要以<code>Command</code>结尾，前面的<code>Example</code>名称进行 1）单词分割 2）_连接 3）首字母小写 转变后为此命令调用名称。eg: <code>CabbageFileDiffCommand</code>其调用命令为<code>cabbage_file_diff</code>。</p><p>在sublime控制台中输入<code>view.run_command(&#39;example&#39;)</code>，即在界面中插入”Hello, World!”（view为当前编辑框，可控制台自动导入）。</p><p><a href="http://mux.alimama.com/posts/549#sublime.View" target="_blank" rel="noopener">Sublime插件开发API手册[中文版]</a>在编写插件时，可以随时参考API。</p><p>Sublime Plugin可继承的类有如下四个：</p><ul><li>TextCommand: 通过View对象来访问选择的/缓存区的内容，最为常用</li><li>WindowCommand: 通过Window对象来引用当前窗口</li><li>ApplicationCommand: 既不能引用文字内容，也不能引用窗口，无视之</li><li>EventListener: 文档发生改变时的事件处理</li></ul><p>ok，介绍到这里就可以对着API开发了。这里再提一句，如下代码参考<a href="https://github.com/zhangCabbage/SublimeFileDiffs" target="_blank" rel="noopener"><code>SublimeFileDiffs fork</code></a>，原地址：<a href="https://github.com/colinta/SublimeFileDiffs" target="_blank" rel="noopener"><code>SublimeFileDiffs</code></a>。</p><p>直接开撕代码，注释讲解，方便大家很快的了解重点。<strong>一个view即为编辑器中一个tab</strong>！<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import sublime</span><br><span class="line">import sublime_plugin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class CabbageFileDiffCommand(sublime_plugin.TextCommand):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    main command</span><br><span class="line">    </span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def run(self, edit):</span><br><span class="line">        views = self.view.window().views() #获取当前tab其窗口实例，并获取所有打开的 tab view</span><br><span class="line">        if len(views) != 2:</span><br><span class="line">            # 只比较两个打开的tab</span><br><span class="line">            return</span><br><span class="line"></span><br><span class="line">        contents = []</span><br><span class="line">        for v in views:</span><br><span class="line">            #遍历所有 tab view</span><br><span class="line">            this_content = v.substr(sublime.Region(0, v.size())) #view选中全部区域</span><br><span class="line">            this_content = sorted(this_content.split()) #分割，排序</span><br><span class="line">            contents.append(this_content)</span><br><span class="line">        diffs = self.file_diff(contents[0], contents[1])</span><br><span class="line"></span><br><span class="line">        scratch = self.view.window().new_file() #新建一个tab</span><br><span class="line">        scratch.set_scratch(True)</span><br><span class="line">        scratch.set_syntax_file(&apos;Packages/Diff/Diff.tmLanguage&apos;) #tab中的语法格式，方便更明显的看到结果</span><br><span class="line">        scratch.run_command(&apos;my_dump&apos;, &#123;&apos;diffs&apos;: diffs&#125;) #到要插入的比较结果的 tab view下执行插入命令，并传入命令参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    def file_diff(self, first_content, second_content):</span><br><span class="line">        &quot;&quot;&quot;[summary]</span><br><span class="line">        比较 first tab 和 second tab 内容的排序后的内容，按需拼接格式并返回输出</span><br><span class="line"></span><br><span class="line">        Diff.tmLanguage的语法格式：</span><br><span class="line">            空格开头的灰色</span><br><span class="line">            +开头绿色</span><br><span class="line">            -开头红色</span><br><span class="line"></span><br><span class="line">        约定最后结果灰色为两文件共有，+开头为+++ first文件独有，-开头为--- second文件独有</span><br><span class="line">        @@  3,+1,-1  @@，其中无符号为共有单词个数，正数为first文件独有单词个数，负数为second文件独有单词个数</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        ...</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class MyDumpCommand(sublime_plugin.TextCommand):</span><br><span class="line">    def run(self, edit, diffs):</span><br><span class="line">        self.view.insert(edit, 0, diffs)</span><br></pre></td></tr></table></figure><p></p><p>最后添加右键菜单，在同一路径下新建<code>Context.sublime-menu</code>文件，文件内容<br>其中<code>{ &quot;caption&quot;: &quot;-&quot; }</code>为菜单分割<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">   &#123; &quot;caption&quot;: &quot;-&quot; &#125;, </span><br><span class="line">   &#123; &quot;caption&quot;: &quot;Cabbage File Diff&quot;, &quot;command&quot;: &quot;cabbage_file_diff&quot; &#125;,</span><br><span class="line">   &#123; &quot;caption&quot;: &quot;-&quot; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p></p><p>到此，娱乐项目结束。ヾ(｡｀Д´｡)是的，就是这么水（逃。。。</p><h2 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h2><p>给两个文件<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello World</span><br><span class="line">zhang</span><br><span class="line">jiahua</span><br></pre></td></tr></table></figure><p></p><p>与<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">zhang</span><br><span class="line">jiahua</span><br><span class="line">hai</span><br><span class="line">zeiwang</span><br></pre></td></tr></table></figure><p></p><p>点击右键如下图：<br><img src="/images/technology/sublime1.jpg" alt=""><br>然后结果即如下图：<br><img src="/images/technology/sublime2.jpg" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://zxhfighter.github.io/blog/javascript/2013/07/30/sublime-plugin.html" target="_blank" rel="noopener">编写你的第一个sublime插件</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;需求来了&quot;&gt;&lt;a href=&quot;#需求来了&quot; class=&quot;headerlink&quot; title=&quot;需求来了&quot;&gt;&lt;/a&gt;需求来了&lt;/h2&gt;&lt;p&gt;最近总是需要review旧的业务代码进行重构，这个过程中涉及不少sql字段的比较。可类比比较两个无序字符串数组的异同，跟普通的&lt;code&gt;filediff&lt;/code&gt;需求略微不同。虽然可以写一个脚本来处理，但是这样每次都需要对比较的字段新建文件。而通常的应用场景是想直接把内容复制到&lt;code&gt;sublime view&lt;/code&gt;缓存中进行比较，而不需要新建文件。&lt;/p&gt;&lt;p&gt;我试图寻找此需求的sublime插件：&lt;a href=&quot;https://packagecontrol.io/packages/FileDiffs&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;FileDiffs&lt;/code&gt;&lt;/a&gt;、&lt;a href=&quot;https://packagecontrol.io/packages/Compare%20Side-By-Side&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Compare Side-By-Side&lt;/code&gt;&lt;/a&gt;等，由于无法进行无序比较，效果都不是很好。之后尝试接入sublime plugin API，参考&lt;code&gt;FileDiffs&lt;/code&gt;的展示效果，做个简易的适合自己需求的小插件&lt;code&gt;Cabbage File Diff&lt;/code&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="工具" scheme="http://zhangcabbage.cn/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://zhangcabbage.cn/tags/%E5%B7%A5%E5%85%B7/"/>
    
      <category term="插件" scheme="http://zhangcabbage.cn/tags/%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Majority Number --- 出现次数超过数组长度1/n的数字</title>
    <link href="http://zhangcabbage.cn/2017/Majority-Number-%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A61-n%E7%9A%84%E6%95%B0%E5%AD%97.html"/>
    <id>http://zhangcabbage.cn/2017/Majority-Number-出现次数超过数组长度1-n的数字.html</id>
    <published>2017-04-10T12:23:37.000Z</published>
    <updated>2017-06-10T13:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>为了循序渐进的说明问题，我们先给出如下问题：找出数组中出现次数超过其长度<code>1/2</code>的数字？<br>要求时间复杂度<code>O(n)</code>, 空间复杂度<code>O(1)</code></p><a id="more"></a><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这道题在<code>剑指offer</code>、<code>leetcode</code>、<code>lintcode</code>等很多地方都能看到。</p><p>最容易想到的解法：统计各不同元素出现个数，大于<code>1/2</code>即为解，但是如此空间复杂度就达不到要求。</p><p>排序统计：先排个序，再统计，似乎能达到<code>O(1)</code>的空间复杂度。不过比较排序算法的最快时间复杂度为<code>O(nlogn)</code>, 为了达到要求只能使用<code>O(n)</code>的排序算法，<code>基数排序</code>似乎能满足需求。</p><p>本篇博文<code>基数排序</code>不是我们的重点（桶排序、计数排序、基数排序的区别大家能弄明白么？广告：之后可能会写关于排序的专题，有兴趣请持续关注白菜君的博客…），我们要说的是<code>抵消算法</code>。超过一半的数字，如果与剩余和它不同的数相抵消，最后剩下的数就是出现次数超过一半的数字。</p><p>Java代码如下:<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static int more_1_2(int[] nums) throws Exception &#123;</span><br><span class="line">    int x = 0;</span><br><span class="line">    int cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (cnt == 0) &#123;</span><br><span class="line">            x = nums[i];</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (x != nums[i]) cnt--;</span><br><span class="line">            else cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //判断是否有这样的数</span><br><span class="line">    cnt = 0;</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] == x) cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    if (cnt &gt; nums.length / 2) return x;</span><br><span class="line">    else throw new Exception(&quot;数组不存在超过1/2的元素&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><h3 id="扩展问题"><a href="#扩展问题" class="headerlink" title="扩展问题"></a>扩展问题</h3><p>找出数组中出现次数超过其长度<code>1/3</code>的数字？要求时间复杂度<code>O(n)</code>, 空间复杂度<code>O(1)</code></p><h3 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h3><p><a href="http://baike.baidu.com/link?url=sgSk4xe30_4Xxr4W9oQisqt_mcRrtGRilnh9EzZjBLqp9DkXqolv8c2Yc6MahCY0C4PswiU3pBaK9vTp1V8JzeXIL1wBf1qGkumcGex1GiQkU7GqB4Mazqcp0TeB748y" target="_blank" rel="noopener"><code>头脑风暴</code></a>百度百科关键词会跟上<code>一种创造能力的集体训练法</code>，在我这里日常却是<code>头脑风暴(精神错乱状态)</code>。</p><p>有兴趣的了解博主脑回路的可以继续往下看，如果时间紧(哥们儿分分钟几百万上下，赶紧的)，那就请移步下个小节。</p><p>我曾试图把数组分成3个部分<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------+-----------+-----------+</span><br><span class="line">|    &lt;1&gt;    |    &lt;2&gt;    |    &lt;3&gt;    |</span><br><span class="line">+-----------+-----------+-----------+</span><br><span class="line">|  0 - 1/3  | 1/3 - 2/3 |  2/3 - 1  |</span><br><span class="line">+-----------+-----------+-----------+</span><br></pre></td></tr></table></figure><p></p><p>对<code>&lt;1,2&gt;</code>、<code>&lt;1,3&gt;</code>、<code>&lt;2,3&gt;</code>、这三个部分分别采用<code>1/2</code>的方式，想着在<code>2/3</code>中超过<code>1/3</code>不就是超过<code>1/2</code>么？</p><p>再经过一番头脑风波，发现忽略了一种情况：假如超过<code>1/3</code>的元素分别分布在<code>&lt;1&gt;</code>、<code>&lt;2&gt;</code>、<code>&lt;3&gt;</code>中，而这三部分其中任意两部分加起来都不超过<code>1/2</code>!!</p><p>如果在我这个思路下，你有什么想法，欢迎在博文下方评论告知。</p><h3 id="洗脑风暴"><a href="#洗脑风暴" class="headerlink" title="洗脑风暴"></a>洗脑风暴</h3><p>下面开始洗脑，把人民群众拉回共产主义正确道路上来。</p><p>主要思路：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">我们知道超过1/3次数的数字个数不超过2个。类似抵消的思想，假如有3个数不相同，那么我们就让它们抵消掉。</span><br><span class="line"></span><br><span class="line">两个int存储两个数，两个int分别存储两个数出现的次数cnt。</span><br><span class="line">遍历数组遇到相同的cnt++, 遇到与两个数都不同的，那么两个数对应的cnt--。</span><br></pre></td></tr></table></figure><p></p><p>代码如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 我是个很懒的人，能写一行的代码绝不写两行. 所以使用数组来存储，也导致代码中break的问题</span><br><span class="line"> * 注意我为什么使用break</span><br><span class="line"> *</span><br><span class="line"> * @param nums</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public static List&lt;Integer&gt; more_1_3(int[] nums) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    if (nums.length &lt; 3) &#123;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i == 1 &amp;&amp; nums[1] == nums[0]) continue;</span><br><span class="line">            res.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int[] tmp = new int[2];</span><br><span class="line">    int[] cnt = new int[2];</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] == tmp[0]) cnt[0]++;</span><br><span class="line">        else if (nums[i] == tmp[1]) cnt[1]++;</span><br><span class="line">        else if (cnt[0] == 0) &#123;</span><br><span class="line">            tmp[0] = nums[i];</span><br><span class="line">            cnt[0]++;</span><br><span class="line">        &#125; else if (cnt[1] == 0) &#123;</span><br><span class="line">            tmp[1] = nums[i];</span><br><span class="line">            cnt[1]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            cnt[0]--;</span><br><span class="line">            cnt[1]--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //验证两数是否为超过1/3元素</span><br><span class="line">    cnt = new int[2];</span><br><span class="line">    for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; tmp.length; j++) &#123;</span><br><span class="line">            if (nums[i] == tmp[j]) &#123;</span><br><span class="line">                cnt[j]++;</span><br><span class="line">                break;  //这里加break, 防止连续两次+1的情况。eg: &#123;0, 0, 0&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; tmp.length; i++) &#123;</span><br><span class="line">        if (cnt[i] &gt; nums.length / 3) &#123;</span><br><span class="line">            res.add(tmp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之后<code>1/n</code>的情况自然而然就能扩展出去了，大家可以在如下地址进行练习：</p><p>leetcode: <a href="https://leetcode.com/problems/majority-element-ii/" target="_blank" rel="noopener">Majority Element II | LeetCode OJ</a><br>lintcode: <a href="http://www.lintcode.com/en/problem/majority-number-ii/" target="_blank" rel="noopener">Majority Number II</a></p><p>打完收工！</p><p>读者：这是什么武功？<br>博主：想学啊你，我教你啊。。。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;为了循序渐进的说明问题，我们先给出如下问题：找出数组中出现次数超过其长度&lt;code&gt;1/2&lt;/code&gt;的数字？&lt;br&gt;要求时间复杂度&lt;code&gt;O(n)&lt;/code&gt;, 空间复杂度&lt;code&gt;O(1)&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://zhangcabbage.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://zhangcabbage.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Guava源码分析(1) --- ComparisonChain</title>
    <link href="http://zhangcabbage.cn/2017/Guava%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-ComparisonChain.html"/>
    <id>http://zhangcabbage.cn/2017/Guava源码分析-1-ComparisonChain.html</id>
    <published>2017-02-17T11:19:30.000Z</published>
    <updated>2017-02-22T11:46:54.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:01 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>果然我还是话多，总想在前言整个大新闻orz. 本篇文章主要讲解<a href="https://github.com/google/guava" target="_blank" rel="noopener"><code>Guava</code></a>如何简化<code>Object</code>的<code>toString</code>和<code>compareTo</code>方法的实现，着重分析<code>ComparisonChain</code>如何实现懒比较。具体涉及到源码中<code>MoreObjects</code>和<code>ComparisonChain</code>的实现，附带<code>Fluent Interface</code>等…</p><p><code>Guava</code>是<code>Google</code>提供的<code>Java</code>核心工具库，截止当前时刻最新版本为<code>Guava 21.0</code>，本文的源码分析也是基于此版本进行的<br><a id="more"></a></p><h2 id="MoreObjects"><a href="#MoreObjects" class="headerlink" title="MoreObjects"></a>MoreObjects</h2><p>自<code>Java7</code>之后，<code>Guava</code>推荐使用<code>sun</code>官方实现的<code>Objects</code>，<code>Guava</code>本身的<code>Objects</code>基本没有任何作用。以前版本的<code>toString</code>工具方法也已转移到新类<code>MoreObjects</code>之中。我们知道Java原生<code>toString</code>方法对于对象会返回<code>类全名 + @ + 对象地址</code>；假如为数组对象，则返回<code>[ + 类型 + @ + 对象地址</code>，这样非常不友好。我们可以通过<code>MoreObjects</code>类来覆写<code>toString</code>方法，进行友好输出。如下栗子<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);  <span class="comment">//打印 [I@3cd1a2f1</span></span><br><span class="line"></span><br><span class="line">String out = MoreObjects.toStringHelper(<span class="string">"MyTestClass"</span>).addValue(<span class="keyword">true</span>).add(<span class="string">"second"</span>, <span class="number">12</span>).toString();</span><br><span class="line">System.out.println(out);  <span class="comment">//打印 MyTestClass&#123;true, second=12&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>关于<code>MoreObjects.toStringHelper</code>的实现。<br><code>toStringHelper</code>为<code>MoreObjects</code>的静态内部类，通过<code>MoreObjects.toStringHelper(&quot;&quot;)</code>来构造对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MoreObjects源码，这里只复制关键部分</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreObjects</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ToStringHelper <span class="title">toStringHelper</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ToStringHelper(className);</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringHelper</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String className;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ValueHolder holderHead = <span class="keyword">new</span> ValueHolder();</span><br><span class="line">    <span class="keyword">private</span> ValueHolder holderTail = holderHead;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ToStringHelper</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.className = checkNotNull(className);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MoreObjects</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看到<code>toStringHelper</code>的构造方法访问权限修饰词为<code>private</code>，为什么<code>MoreObjects</code>外部类在方法<code>toStringHelper</code>中可以访问？<br><code>private</code>修饰的意思是：<strong>除包含该成员的类之外，其他任何类都无法访问这个成员</strong>。外部类包含内部类，可以理解为包含内部类所有，故也能被访问！</p><p><code>toStringHelper</code>类中以<code>ValueHolder</code>形式<strong>带头结点的链表</strong>来存储传入的键值对。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ToStringHelper</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ValueHolder holderHead = <span class="keyword">new</span> ValueHolder();</span><br><span class="line">  <span class="keyword">private</span> ValueHolder holderTail = holderHead;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">private</span> ValueHolder <span class="title">addHolder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueHolder valueHolder = <span class="keyword">new</span> ValueHolder();</span><br><span class="line">    holderTail = holderTail.next = valueHolder;</span><br><span class="line">    <span class="keyword">return</span> valueHolder;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function"><span class="keyword">private</span> ToStringHelper <span class="title">addHolder</span><span class="params">(String name, @Nullable Object value)</span> </span>&#123;</span><br><span class="line">    ValueHolder valueHolder = addHolder();</span><br><span class="line">    valueHolder.value = value;</span><br><span class="line">    valueHolder.name = checkNotNull(name);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    Object value;</span><br><span class="line">    ValueHolder next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于链表的插入，程序非常优雅的分成<strong>添加结点</strong>和<strong>赋值</strong>两部分，见上源码<code>无参addHolder</code>和<code>有参addHolder</code>。使用连续赋值进行尾指针调整，<code>holderTail = holderTail.next = valueHolder</code>，这样感觉简便的多，可以参考！</p><h2 id="ComparisonChain"><a href="#ComparisonChain" class="headerlink" title="ComparisonChain"></a>ComparisonChain</h2><p>Java中实现类的一个比较器Comparator，有时也略麻烦。对于一个有三个成员的类<code>People</code>，它的比较器的实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String lastName;</span><br><span class="line">  <span class="keyword">private</span> String firstName;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> zipCode;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//compareTo方法，很不直观</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person other)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cmp = lastName.compareTo(other.lastName);</span><br><span class="line">    <span class="keyword">if</span> (cmp != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    cmp = firstName.compareTo(other.firstName);</span><br><span class="line">    <span class="keyword">if</span> (cmp != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> cmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Integer.compare(zipCode, other.zipCode);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//基于ComparisonChain的实现，则非常直观。</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Foo that)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ComparisonChain.start()</span><br><span class="line">            .compare(<span class="keyword">this</span>.aString, that.aString)</span><br><span class="line">            .compare(<span class="keyword">this</span>.anInt, that.anInt)</span><br><span class="line">            .compare(<span class="keyword">this</span>.anEnum, that.anEnum, Ordering.natural().nullsLast())</span><br><span class="line">            .result();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p>从上面的代码我们可以发现：基于<code>ComparisonChain</code>实现的比较器非常直观。<br>这里先介绍一下，上面这个可以连续引用方法的接口方式为<a href="https://zh.wikipedia.org/wiki/%E6%B5%81%E5%BC%8F%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener"><code>Fluent Interface</code></a>。通过在方法中返回对象本身(<code>return this</code>)，可以很容易实现。</p><p><code>ComparisonChain</code>最关键的是能实现<strong>懒比较</strong>：执行比较操作直至发现非零的结果，在那之后的比较输入将被忽略。拿上面的栗子来说，也就是当<code>aString</code>能比较出两个对象的大小后，之后的<code>anInt</code>和<code>anEnum</code>就不再比较，更快速！那么如何实现<strong>懒比较coding</strong>呢？</p><p><code>ComparisonChain</code>类源码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComparisonChain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ComparisonChain</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ComparisonChain <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ACTIVE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ComparisonChain ACTIVE =</span><br><span class="line">      <span class="keyword">new</span> ComparisonChain() &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ComparisonChain <span class="title">compare</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> classify(Ints.compare(left, right));</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">        <span class="function">ComparisonChain <span class="title">classify</span><span class="params">(<span class="keyword">int</span> result)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> (result &lt; <span class="number">0</span>) ? LESS : (result &gt; <span class="number">0</span>) ? GREATER : ACTIVE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ComparisonChain LESS = <span class="keyword">new</span> InactiveComparisonChain(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ComparisonChain GREATER = <span class="keyword">new</span> InactiveComparisonChain(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>抽象类<code>ComparisonChain</code>的<code>start</code>方法返回一个实现了抽象类的实例对象<code>ACTIVE</code>，此实例对象每个抽象方法实现都覆盖一层<code>classify</code>操作，来判断返回<code>ACTIVE</code>、<code>GREATER</code>、<code>LESS</code>哪个<code>ComparisonChain</code>实例对象。</p><p><code>ACTIVE</code>对象表示两对象比较结果为<code>0</code>的<code>ComparisonChain</code>实例，<code>GREATER</code>对象表示两对象比较结果为<code>1</code>的<code>ComparisonChain</code>实例，<code>LESS</code>对象表示两对象比较结果为<code>-1</code>的<code>ComparisonChain</code>实例。</p><p>我们再来看一下表示<code>GREATER</code>、<code>LESS</code>的实现类<code>InactiveComparisonChain</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">InactiveComparisonChain</span> <span class="keyword">extends</span> <span class="title">ComparisonChain</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> result;</span><br><span class="line"></span><br><span class="line">  InactiveComparisonChain(<span class="keyword">int</span> result) &#123;</span><br><span class="line">    <span class="keyword">this</span>.result = result;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ComparisonChain <span class="title">compare</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ComparisonChain <span class="title">compare</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所有抽象方法实现均只返回自身(<code>return this</code>)，不进行任何操作。ok如此便进行了编码上的懒实现，各位看官群众们知道其中缘由了么？</p><p>那么我来分析一下：<br>每次比较通过<code>classify</code>方法处理，结果都会是<code>ACTIVE</code>、<code>GREATER</code>、<code>LESS</code>一种，它们都是<code>ComparisonChain</code>抽象类的实现实例对象，故而可以构成<code>Fluent Interface</code>。</p><p>而如果比较返回的是<code>GREATER</code>或<code>LESS</code>，由于其<code>compare</code>实现为<code>return this</code>，不进行任何处理，故而忽略<code>ComparisonChain.start().compare(this.aString, that.aString).compare(this.anInt, that.anInt).result()</code>有结果之后的比较输入<code>.compare(this.anInt, that.anInt)...</code></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.raychase.net/263" target="_blank" rel="noopener"><code>关于接口设计，还有Fluent Interface，这种有趣的接口设计风格</code></a><br><a href="http://ifeve.com/google-guava-commonobjectutilities/" target="_blank" rel="noopener"><code>[Google Guava] 1.3-常见Object方法</code></a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:01 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;果然我还是话多，总想在前言整个大新闻orz. 本篇文章主要讲解&lt;a href=&quot;https://github.com/google/guava&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;Guava&lt;/code&gt;&lt;/a&gt;如何简化&lt;code&gt;Object&lt;/code&gt;的&lt;code&gt;toString&lt;/code&gt;和&lt;code&gt;compareTo&lt;/code&gt;方法的实现，着重分析&lt;code&gt;ComparisonChain&lt;/code&gt;如何实现懒比较。具体涉及到源码中&lt;code&gt;MoreObjects&lt;/code&gt;和&lt;code&gt;ComparisonChain&lt;/code&gt;的实现，附带&lt;code&gt;Fluent Interface&lt;/code&gt;等…&lt;/p&gt;&lt;p&gt;&lt;code&gt;Guava&lt;/code&gt;是&lt;code&gt;Google&lt;/code&gt;提供的&lt;code&gt;Java&lt;/code&gt;核心工具库，截止当前时刻最新版本为&lt;code&gt;Guava 21.0&lt;/code&gt;，本文的源码分析也是基于此版本进行的&lt;br&gt;
    
    </summary>
    
      <category term="源码" scheme="http://zhangcabbage.cn/categories/%E6%BA%90%E7%A0%81/"/>
    
    
      <category term="Guava" scheme="http://zhangcabbage.cn/tags/Guava/"/>
    
      <category term="源码" scheme="http://zhangcabbage.cn/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>书评(三)：大型网站技术架构 -- 核心原理与案例分析</title>
    <link href="http://zhangcabbage.cn/2017/%E4%B9%A6%E8%AF%84-%E4%B8%89-%EF%BC%9A%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84-%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.html"/>
    <id>http://zhangcabbage.cn/2017/书评-三-：大型网站技术架构-核心原理与案例分析.html</id>
    <published>2017-02-08T12:39:19.000Z</published>
    <updated>2017-02-08T08:35:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>书评系列这是第三篇，稍微看过前两篇的胖友们肯定知道了：<strong>说是书评，其实只能算是我的读书笔记</strong>。<a href="http://baike.baidu.com/link?url=DSV2SG3XWPmihRkeO7ws53jWDAA3jvrNO2kJrHFwE51Uoj6K8pktSj7RnzBnCZYtbfSSiJZNJHX0cU4wrgal9iqSaLFguAUOX4534hrbe23" target="_blank" rel="noopener"><code>评论</code></a>这个词偏向于向别人阐述自己的主观印象，想到此系列一方面作为自己的读书笔记，另一方面想供阅读对应书目的人作为参考，所以也很无耻的用了<strong>书评</strong>二字（相信大家也习惯了我，每篇第一段的瞎扯，哈，哈，哈…</p><p>我想大部分程序猿的编程之路都或多或少的从网站起步，固然搭建一个网站说难不难。github上随便down一个网上购物的代码调试搭建，后台数据处理臆想中也无非增删改查，so easy。然而学习网站编程也是这么简单么，实则不然！</p><p>任何一门技术都像武侠中的练武一样，一招半式或许不难，难的是学精并融会贯通。学习过程中很多时候我们都感觉像摸瞎般的龃龉前行，假如有老师或者像看书目录一样的提纲挈领的指明方向，那么肯定会事半功倍。而今天推荐的这本书正是网站学习中的九阳真经目录！<code><a href="/2017/书评-二-：SQL必知会-第4版.html" title="点击这里查看[书评系列]上篇文章">点击这里查看[书评系列]上篇文章</a></code></p><p><strong>《大型网站技术架构 – 核心原理与案例分析》，推荐力度：★★★★☆</strong><br>不得不说这本书是大型网站技术架构方面的神作！<br><a id="more"></a></p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>概括：<strong>本书详细叙述了大型网站架构的演化，并从高性能、高可用、伸缩性、可扩展和安全五个方面进行深入剖析，并使用栗子进行说明。关于网站架构的阐述高屋建瓴，不仅对架构师帮助巨大，还非常有助于提升技术猿的全局观</strong>。</p><p>本书分四个部分：网站架构演化概述、五大特征架构详解、网站架构案例、架构师艺术。最后一部分我就没有看，而本篇书评也请容许我无耻的照搬书中关于<strong>网站架构演化</strong>部分，主要是因为感觉比较经典。</p><h3 id="大型网站架构演化"><a href="#大型网站架构演化" class="headerlink" title="大型网站架构演化"></a>大型网站架构演化</h3><p>1）初始阶段LAMP(Linux+Apache+MySQL+PHP)，一台服务器<br><img src="/images/booksReview/series_3/1.jpg" alt=""><br>2）应用、数据、文件分离，针对业务选用不同硬件配置服务器<br><img src="/images/booksReview/series_3/2.jpg" alt=""><br>3）<strong>二八原则</strong>：80%业务集中在20%的数据上，<strong>增加缓存</strong><br><img src="/images/booksReview/series_3/3.jpg" alt=""><br>4）采用应用服务器集群(每台服务器同样应用)，使用<strong>负载均衡</strong>服务器改善负载<br><img src="/images/booksReview/series_3/4.jpg" alt=""><br>5）<strong>数据库读写分离</strong>，构建单独的数据访问模块<br><img src="/images/booksReview/series_3/5.jpg" alt=""><br>6）针对数据传输改进，主要利用缓存，增加CDN(内容分发网络)和反向代理<br><img src="/images/booksReview/series_3/6.jpg" alt=""><br>7）<strong>分布式文件和分布式数据库</strong><br><img src="/images/booksReview/series_3/7.jpg" alt=""><br>8）针对本站内容的检索服务，<strong>增加NoSQL和搜索引擎服务器</strong><br><img src="/images/booksReview/series_3/8.jpg" alt=""><br>9）随着业务继续发展，<strong>拆分网站成不同应用</strong>，独立部署维护<br><img src="/images/booksReview/series_3/9.jpg" alt=""><br>10）分拆的不同应用主要是通过同一数据存储系统来进行关联，所以分拆应用越多，数据库压力越大。为了解决类似的问题，提取共用业务成<strong>分布式服务</strong>。比如访问数据库、存取文件这类服务，各个应用统一交给某一服务代理。<br><img src="/images/booksReview/series_3/10.jpg" alt=""></p><p>这里作者最后指出<strong>网站架构的价值不在于搭建大型网站的技术，而在于能随着网站的需求灵活应对</strong>。</p><h3 id="五大特征架构详解"><a href="#五大特征架构详解" class="headerlink" title="五大特征架构详解"></a>五大特征架构详解</h3><p>同样为了清晰方便，这里使用思维导图来展示。<br><img src="/images/booksReview/series_3/大型网站技术架构分析.png" alt=""></p><h3 id="发散思维"><a href="#发散思维" class="headerlink" title="发散思维"></a>发散思维</h3><p>反向代理和负载均衡的关系？<br>Web容器是什么，为什么需要？<br>防火墙的作用，为什么有了杀毒软件还需要防火墙？</p><blockquote><p>受限于博主个人知识面，以上仅个人看法，欢迎批评指正。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;书评系列这是第三篇，稍微看过前两篇的胖友们肯定知道了：&lt;strong&gt;说是书评，其实只能算是我的读书笔记&lt;/strong&gt;。&lt;a href=&quot;http://baike.baidu.com/link?url=DSV2SG3XWPmihRkeO7ws53jWDAA3jvrNO2kJrHFwE51Uoj6K8pktSj7RnzBnCZYtbfSSiJZNJHX0cU4wrgal9iqSaLFguAUOX4534hrbe23&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;code&gt;评论&lt;/code&gt;&lt;/a&gt;这个词偏向于向别人阐述自己的主观印象，想到此系列一方面作为自己的读书笔记，另一方面想供阅读对应书目的人作为参考，所以也很无耻的用了&lt;strong&gt;书评&lt;/strong&gt;二字（相信大家也习惯了我，每篇第一段的瞎扯，哈，哈，哈…&lt;/p&gt;&lt;p&gt;我想大部分程序猿的编程之路都或多或少的从网站起步，固然搭建一个网站说难不难。github上随便down一个网上购物的代码调试搭建，后台数据处理臆想中也无非增删改查，so easy。然而学习网站编程也是这么简单么，实则不然！&lt;/p&gt;&lt;p&gt;任何一门技术都像武侠中的练武一样，一招半式或许不难，难的是学精并融会贯通。学习过程中很多时候我们都感觉像摸瞎般的龃龉前行，假如有老师或者像看书目录一样的提纲挈领的指明方向，那么肯定会事半功倍。而今天推荐的这本书正是网站学习中的九阳真经目录！&lt;code&gt;&lt;a href=&quot;/2017/书评-二-：SQL必知会-第4版.html&quot; title=&quot;点击这里查看[书评系列]上篇文章&quot;&gt;点击这里查看[书评系列]上篇文章&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;《大型网站技术架构 – 核心原理与案例分析》，推荐力度：★★★★☆&lt;/strong&gt;&lt;br&gt;不得不说这本书是大型网站技术架构方面的神作！&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://zhangcabbage.cn/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="书评" scheme="http://zhangcabbage.cn/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>书评(二)：SQL必知会(第4版)</title>
    <link href="http://zhangcabbage.cn/2017/%E4%B9%A6%E8%AF%84-%E4%BA%8C-%EF%BC%9ASQL%E5%BF%85%E7%9F%A5%E4%BC%9A-%E7%AC%AC4%E7%89%88.html"/>
    <id>http://zhangcabbage.cn/2017/书评-二-：SQL必知会-第4版.html</id>
    <published>2017-02-03T08:15:00.000Z</published>
    <updated>2017-02-07T14:21:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>过年在家，瓜子花生、鸭肉羊肉、吃吃睡睡、电视电影…忙碌浪荡十多天，期间看了这本SQL必知会。老实讲看技术书是需要<code>效率+动手</code>，然而在家我也没法要求我自己额，真是个没有自制力的熊孩子。</p><p>拉回正题，继续瞎侃（坐稳嘞老司机要开车了）。因为我一般常是<strong>结合搜索引擎需求驱动学习</strong>，加上精力分散没有系统深入学习，以致SQL水平一直停留在简单的增删改查。甚至更差，比如常混淆<code>group by和having的使用</code>、<code>group by、having与order by的语句顺序</code>等。果然缺乏系统的学习理解，导致要么死记硬背久了就忘，要么理解偏差认识不全。在知乎逛看人都推荐<code>SQL必知会</code>入门，这次就来补下使用基础。<code><a href="/2017/书评-一-：Java多线程编程核心技术.html" title="点击这里查看[书评系列]上篇文章">点击这里查看[书评系列]上篇文章</a></code></p><p><strong>《SQL必知会》，推荐力度：★★★☆☆</strong><br><a id="more"></a></p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>概括：<strong>本书是针对SQL使用方面的简单介绍，较为系统全面却不啰嗦乏味；概念清晰而不拘泥某一个DBMS软件，为深入学习做了很好的铺垫。</strong></p><p>本书共22个课时，150页左右。关于书的内容，我简单使用<a href="https://www.zhihu.com/question/19651621" target="_blank" rel="noopener"><code>思维导图</code></a>进行总结，如下所示<br><img src="/images/booksReview/SQL必知会.png" alt=""></p><p>关于书中细节，我简单扼要的圈出我认为的重点，概括为基本语法：<br>1）不区分大小写。建议关键字大写，表名列名小写<br>2）每条SQL语句最好以<code>;</code>结束<br>3）注释语法，单条<code>-- balabala</code>或<code># balabala</code>，多条<code>/*balabala*/</code><br>4）<code>Distinct</code>语法，作用于其后所有列<br>5）<code>DESC</code>与<code>ASC(Default)</code>只作用于其前一列<br>6）Between关键字包含开始和结束值<br>7）如果没有括号<code>()</code>，先处理<code>AND</code>，再处理<code>OR</code><br>8）通配符关键字<code>LIKE</code>，通配符%(匹配任何字符，除<code>NULL</code>)、-(单个字符)<br>9）除聚集计算语句外，select中每一列都必须在<code>group by</code>中<br>10）<code>group by</code>用来分组，<code>having</code>用来过滤分组<br>11）select子句顺序：<code>select -&gt; from -&gt; where -&gt; group by -&gt; having -&gt; order by</code><br>12）所有DBMS操作，都有底层SQL语言的支持。同样，应用层高级编程语言的sql操作都是需要SQL原语的支持。就像python中的游标，本身就有SQL支持，语言库封装使用的。这个突然想到python中MySQLdb库的MySQL操作，都是在游标cursor基础上进行的，执行完后在数据库连接conn上进行commit操作。python代码如下：<br></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">conn = MySQLdb.connect()</span><br><span class="line">cur = conn.cursor()</span><br><span class="line">sql = <span class="string">"..."</span></span><br><span class="line">res = cur.execute(sql)</span><br><span class="line">conn.commit()</span><br></pre></td></tr></table></figure><p></p><blockquote><p>受限于博主个人知识面，以上仅个人看法，欢迎批评指正。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;过年在家，瓜子花生、鸭肉羊肉、吃吃睡睡、电视电影…忙碌浪荡十多天，期间看了这本SQL必知会。老实讲看技术书是需要&lt;code&gt;效率+动手&lt;/code&gt;，然而在家我也没法要求我自己额，真是个没有自制力的熊孩子。&lt;/p&gt;&lt;p&gt;拉回正题，继续瞎侃（坐稳嘞老司机要开车了）。因为我一般常是&lt;strong&gt;结合搜索引擎需求驱动学习&lt;/strong&gt;，加上精力分散没有系统深入学习，以致SQL水平一直停留在简单的增删改查。甚至更差，比如常混淆&lt;code&gt;group by和having的使用&lt;/code&gt;、&lt;code&gt;group by、having与order by的语句顺序&lt;/code&gt;等。果然缺乏系统的学习理解，导致要么死记硬背久了就忘，要么理解偏差认识不全。在知乎逛看人都推荐&lt;code&gt;SQL必知会&lt;/code&gt;入门，这次就来补下使用基础。&lt;code&gt;&lt;a href=&quot;/2017/书评-一-：Java多线程编程核心技术.html&quot; title=&quot;点击这里查看[书评系列]上篇文章&quot;&gt;点击这里查看[书评系列]上篇文章&lt;/a&gt;&lt;/code&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;《SQL必知会》，推荐力度：★★★☆☆&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://zhangcabbage.cn/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="书评" scheme="http://zhangcabbage.cn/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>16年年终总结 --- 写于农历新年岁末</title>
    <link href="http://zhangcabbage.cn/2017/%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93-%E5%86%99%E4%BA%8E%E5%86%9C%E5%8E%86%E6%96%B0%E5%B9%B4%E5%B2%81%E6%9C%AB.html"/>
    <id>http://zhangcabbage.cn/2017/年终总结-写于农历新年岁末.html</id>
    <published>2017-01-27T15:32:27.000Z</published>
    <updated>2018-02-03T14:57:54.514Z</updated>
    
    <content type="html"><![CDATA[<link href="/style.css" rel="stylesheet" type="text/css"><script src="/crypto-js.js"></script><script src="/mcommon.js"></script><script src="//cdn.bootcss.com/jquery/1.11.3/jquery.min.js"></script> <div id="security"> <div> <div class="input-container"> <input type="password" class="form-control" id="pass" placeholder=" 给打赏，也打不开的小黄文 "/> <label for="pass"> 给打赏，也打不开的小黄文 </label> <div class="bottom-line"></div> </div> </div> </div> <div id="encrypt-blog" style="display:none"> U2FsdGVkX1/IJI/suuw5sL4s5/uIU+8PGGIotAikD8xPbpY/5SrktifsDHrDSS1RZEKq9hgSxdj+Hosg6CXQelWE5A+scgnS18xCHjN26+SkSYQ6moURmE3A3nJ5p5KiWvG25s7S3tc7JcTlZ/U6nqxh5HTQgMdt/HAhShvG27KkaSHFTPoIZypiXNV8/tkhFw+QW39jJpFKcR9icmX8l1ZOyo8GkvOi7ML1m7Df72l6td4Ibj9ACUfwlfFx3KuzhvEpOKdkADw4eNfxIO6KtIe95fJ3+tQ2F7SQJ3CfJQa3o1dGdWwb2IqxNlGegZW5EKiEDat8fKfdakBim/iYWMw+c1pwFj3lAzT2Lgbks1FJJUnDZ0dlvt9Rbcns9YbBwYeDVKvlT5EI31IzZ0Op3MaMmgNC0gnwQNs9l1Td/TOggNrB48v/+0gTyNOxv83S7sRWXK6AobECmFCReX930HqPECa15XOD/jfpfs4PNtNCpSuONnIOGol7MIapbxTLvIYxDj9I6HfCjrOVTXCYQkatCpeXfAJBExOlDCYySlL7SibPT1/neJB1wtCfscjY5uqcO7z66kkKTs66K+Sa2+N8hUWWXJ6P7at/ONPZePz9aZMhT3tGRUsRfbom5Z40Eg/EuNnvcKi2oMAKMTQGffBBsLRsB3bjnOa48D0gQTqZ8ZpzBs9QAyEUPYgUQUKeL5FR3Y8pX4a8cQO9WrLrp51mgcNXvuqFqduouP5h8btEhrgQES9FItzZez1cT+JQoq5K21oiJikkywFzkeWowf+v9/oz0Cy+dERAQ2aHeP2N+HMoGutF+Ct3cIv/O3vHKKhL6l+X9aqVWpHf09rSt2rGB434lSte/tFYFJGFvAmfH1FH5PIFT4PgXZrowOofiGWuE1klcAtkOY+lmSzFsSuDVaIVXoLwyd4hj3xl9h1JK0lmsTLqx8iP1pFnRn9DXuVarHZAZ7+HeRNJm/3a6FmtBLSyZUov/2PLDvxSrr2aqubcObPZ5iaTtTVIGGiTKprIoIOys2a6MmMZ3a9/Z4wcGmRRdz/Z7bi+5kOAI/IwNVq3qs9+sePeDSU1FuiOo0iFRErwhRuybHDsTGxL8R30EV4qQwA3cfc5C/B27zwp1WnqXOvJkVqrkuPJ8PnfnVS1r0U7L93shbZVFpcmXQYOrGF0/P1P6It7S8Juwhyn1kVC5I8OT+dBlGvxxSOlYO6SVjIAg/0UdfjCgcn3QeaEHmE6iG8YYNo8lrOdJaL/ukwSHw6b3iqU7rpgcx4w1nKzTR0hjwfJ9KTg4LWhK/uJnOhwyDDpW3dqgjDDx33V0Df1dO8T20JSR0gTosID8z2v2YD3FuHc8THrrAGt8ocGRO6mevanT41gl/deCMAad+ZTpSJgdHqAixnwB3hvExkScLOvqqVS+o34I2HszJfvpPr+LeUzo3wFNBC83pq9rmbJQCqabKO9aitJxfBTE6T3vxvDLsCJu8iO8+yCQKrKtjj57o6JiweEgFblgQ+YAXJsOFgPq5QPnMQbaB/EnUqHtSO/I6gyFGytBU1JRAU0hpcfCyqOihTtVQ+k24SwZWiZdAbwhias1955ICTnowk9F4Kzd1+Ekp7kN8X9gcHWWdSXc2X74xBRSTkA0UmmlpiQatuOtvdf5NLkWUl7uhRxL4IykMCgJ4qqc5N5OETEKmud11J1VezFuvfDrICjEEUqUAf2NUbMOB8xPNX5UOsudKWXR7GqZk9dMAkB9ajBD+6ZT0/+B+N5EmNdBVSRyLsF+zHnGU4EomB5jKuqkYK0s+B7aJure920Q+qhHXWsLbni9HAtWS8CGPfmM75o4Gf1cTlP9oG4Y6eLlLGvG1RTDUXM4ZUAVLKCn/HxxX8gagVvT4scQYT57/jfgubGy6Z7KAIaxtVAPvGx2izsM3WEjLiVqpQohA1OOCjv/4NCSv+psnh95uFug01tg6SK+iFtoTcd4y4fk0osS8bfCUVBZFbRLJxdGhu8sSwYMxuEzkhSjCiowrzB9rt2R26b6PwvZ6AE+6rQ0ss680HCu1Ytvt/yv/FfzuF1yg32M7xumHE5VrfzsS2U8ozAUyoGgtTM8gNPcAd51uHdi0POm6UrDvsvvi/k+oMPuYMo6FWKLfEqKoFO0lNccOa7S+xtX4H5JXHekhCqpVm3LJH2+5V1L51KIP2+lXjLoV1Eo5nV04kMMxIQfmOBda6eTHpoNp8b4oQ5B+i4oHTenkv+BCeKCmtvcgr7wAE342HkTTHKsptDBIpzBSaM5PRUAm9i7e4DPgw1SkvtTnhYQZWDZBQ8wdRKLbpEYyD5GR5Lspx7G8JrD039Sun6iLbVJNmhofxg370eHiE4U1KXF/QzUGfH/ezgaiNAyGjhKAcGyvSgo49hyZEHuWvMw9k565u2eRZhx0BLWVR6gBRBLsKVLw32BRisSfWiSmCTGTsklmHi6DBOHH4dhqyDk6L8wLTce5Y2gEYUETqet0Ftu9ZnJzc5vSnVWg+8zyQK63CwL5a/ymoSV2i3+AGY5bNTcWxVdBMFivXtPiL55QzUTjVhq/jMemYf3VFmzcX01/X1HS9nfZ+anTVQFg8oOznMsF10InmC66WEgbDH1t0cyJQzJIGy33c1zexFLbZtW0h2T9ihbHH25EJhbuX41iFQQI8oB/nF3j0fywj2VJPu5Q8QGEPOP9PqQreucRXmsw4xbqYo7jEB/ko74GzlSajzpe+8hvlidRFuP79f4TggIaoS95Okr3PIJmbdU+R1W/L4tK8oyHJrnEAEWoJ0OTe9mOoBO8uVUO3xH+iRCuLGDlDfL/FcGnkc3mRmryqyLmz1+06m3R6q0NAdaPdkEgfOoYcmT2GU5eqJx6KzqYDXX+jJSBlC5Mtar62geeEgtE9LhYfOz4PWKONE1FdVBk45kbcG4huQOGCB55rlc4Lo7BknrfIwltzs8sQSX1pFRr8jdgK1hRB1utwyQvHVWSdlJFGo6UdWllnA8cN/dKV8gGELMJbmghKOVsWv14u1xJNGoYrrbozaJ4+U31WijNW03B+NjgQqJ9baT6FJpSt3mXAWm6xSbgcuz2ONl8muiuV+HcORA2O+ZlQsuc4aC05ENukYs0TwS53ivUpYfGuMetlKZU6bdiaJKHmhlp3I1nGdnF6Nb5K+9hx4RYci6XIg0W3SK0Vb3S9otFl9s7g6xdZrUJZdoFTzWrtmRLbZPMp9Sa6enuRuVURNccBq3KlTdLM7NKI9MbdAeyAH+Thmpcky3cVYtTUcApxVLULow4G0ft5S6hI+JIHv0VwXXw3sD9nFXRUsxZArqTOpMK7AUdYEK+TWA39FZukk0/GLZO4uvt+Am3zozOcxGeua91YhMXXb4cMdZxfXb8hNZWQ7TEvwo12eVG4Zg/Z1vA0yxC9Sc8K+E4UgwpeiGRLqm+ZPwOZkBXdR2EKZjAPrcoFsWcYboFMhhyYEdTDGo5BgKoNqy055D4zwTyFBBuC+KsgdPc9Ogb0wI6DbFPwuDkbNNqnhw9g6Ay0MVcXooS/ff/TK9y6nZ1oGOKxwdGDxQr8OW0v6Gorxs/YZkWgaPywx3jvjs7NBezWowIv3Tz2H9ShJGScl2OlolhhrT30Th0wFKofgxypRHA7AMmoEAwrI6SreFMuuL0Wg1GZhDaXN+maojtbvvlTT9Ce5Pp6tjNWW0o9jwM2SpNOtHgmol2K5aQFwYVCeGRmkfJdHVmFQfU8ctcPXzic9l+DWSC98u+rXSE0kt1lZXBQefZzF7o9LrYdgEIPSSJbv7XfINdEzajxZGYWjaMTm/G9wZOFwVZUt9sjJSv78WdZyYYKi036lS0fGJLqvu8VU1SV81DYCl4bVDTizCa+GtOUpR0SLBxnT2zalborpoj6RR1P/GGYUa/2zxlVNbmeIIZgQMlD9P8sjV7EVEjNuDbR4rdQZG1jANUw4L4sdvk1a8XaqlQ0CBEq+ryXN2uR5Gr4rW8ekeQ6gZHpXOTjokTYLuB35vxeukITs+ft8hkxgC7GQw/GS9hZutITXc9dc9A4s0fen0//4AzpV2RuWN+StCq3WHUs8S6g3on0nXwuW1ObNU0nohD8GFziZFHZJiJcFyJwiJ1uKFu1Y7vXNVsw8VADbB3tIsApCUP4QWhrNM9dFCvmVGvfbUFIwc7FicsjBgFyvjf3Rk3EWw9BpTkA+7mbL95y6Gvu/WpkC6X/RAVz/n6niUoTS+Ltgaz5STpA1khpcezruHwm327HnE7sNZZu//6eE3QM7yZuEA1dQZlM6eXgs2nNPCV0Gkiereq2haRMKOk18xrsksOPDwspX/6w3hw2yII8sN/kugrIRdbgcf5UNyonZVmdZfp6pyDeq1Os7x4NYq2XZbXqrWaKVLu3b+iAyB30z2Ln424fcB7pB8ecbMG9rhBmkaIvBZm3xxz3RY2x9RLTIgleMUJ1H7ruu1fbmV7ZqeG7YIsPNubIoBgpuW2VWOS86ogzSoQ1wg84fyE5svfF+M+ryUzcVBbjF6MdTlY6nAvRvRwhl0WZqqM/bhxY2CE7W7clEQwgrP8ajSTj1u96IL79xSn3YHTGgx67idjiQQvQ1Ag72PaoB6oz1w4mWjceBXxHnX4VhpKkMVXuU1E5dsEeE/PRHXiZfG7fXSQoMrVkF3Vo5HetHBz4ALGq5jkvyinDkYBgADHucXItk59Y1+5Gj+k+tXdodxBqEKuC2oXtC9CC3wQZieiFLx2I73TkDmhdMxxqUWCJSWkHV+e8htcHAbOHmxSy/qCdgtL/d3BOk92IeIRDlWSW0Qn9dIbHvp2v4eE7QNQa6YiFHBtAT718c7oX2rqEawLJYQbdMKjkGLwsnYzajcDpWVaFBjAUykcohUVl6UFveLwCG6a73V1s0j43wPx1qA7EPLOmiB9fjtw6CNOg1/NNZCY/jmydXoC+1WE/bX5ba2XLtDy3fszZVUEZs0kS+4ossyz90OY6+jm3LnEtszf8xwOpEe79xjuDctIuV+5awt9BwzvhIsSh1vCY0WRfOr87YLo/PM+JY/kphx1Ef4lSxPvoRndOwGPBuAJvshR3zMjwWnPKhzZtiQFb6i1/QKD9qSVKbmpgzJY3UTYsHgzEcG1WO8TrPWClY+b9TV2clo4xTf+p92o0/QVAb/SuQB7QEoLgsbPUX1a9bURxFH1ML8HYwkB2RAQlleph9rnqfix6VrdCKpwhCvCQeu6A8gywd414HPHm+xtuvP8tfSLKxo/IkHMXd6GRMzgEjSotcCUyragVFmQ+6ntQit74/rhu6oysNxFXAtsONCwieylwAl21zJo3/pUBhpp69jR5/WuMahoNFet6WqYyB3DnfjllxyrAQ9zdR0sZxxXy01jXue168r90XvP3ztJJ2Hie6Y4aG1MQ4eljDx8mq7F8HYsXSkxhRjy9IJvATF0XS53g3x8aqCG4j40xWsR6nHxt/m3UPYQ40ltGZDgBDOliYpdHW6FHikRFCn6TWUHdmxl0wQeZkbN/VZXhccSmLFwEBgIUn9jV78HRnvXSh+UKcYc/VZGa0oc/3Qt7fsoyjRhXeRCTcEIkdSLcJ2hfSUMWGxDvBmmFrpadKW0lH16LF1TWatuA1KhSZMEEKqE6Tsh1FyXAn0Z9x60JUA8Xu5rghl8OD89gm6cbY86Jif/o56OrzoTRhiFNG59Ofi/IEF5oSIhrfveBYiA4tX+/0HmzsNbTmP8K33jsx7zY7HVj1Iyq3OxLMvS8HmMN+sSI7BeKHse/t7DxLW5nl1Q95VqW2o7R1B5Fah7Nb4Qjoo/ogdtEvpv/fHb+8HKQn4xqRDobHOwETwoMtDr7qI44WT4q9bRWE6KMZxi/XNnFcdBwDXILlK4Sqko05PlI7//VmbGeLOT6zyC1R4qDuzftu/NFzUbcd/YSNrwW+4d7e7hfWAvSdlUKXCtx9vSRvS8Pm5c8ohzCwUxb3kGHmAkagXkqEv3JgilPkEWuSAnw8u03pcPMULva/O9wxMG1q7B0bWaT8ee/6kkmgL402tDd2ej7YDfEtrg+4CJNB8JtbJFo6uyJT8nRmSKK6eUUSE7DuBZgtSp8MloZ0KH+Gunb29hL0ORIfVaUl0YpqCgrbXWMOmChj3l4IYY9FOFjUnpzGkpD/8GijhhbazmB5murV2y7s/Lhc1LApFpmDIXFMGAjYfruiaAqlIN/CL7mn+hxKwNrLcrMHW783CE9Anw2heg7BIQHRHgS5zb332m4X8/yoy3FTqXn9gQqytc/vqaLv3+/dYsadfFY3ruT12XFrXficMNtKf39yr2tM7AkBFm6UzPprV5ooU6geBm2MDM/iFv521uNBiwr+/N+Shti5uIvb0+Gu6bupU4IJFvt0Cgpo7A17AGP68d5O5J+wCYNFA17elhBnzWYFKq5oBVaQKsWT0BMJWDLfDCx58GukMKbspRU2DcKSwHGC2fD2Wifz+wVK1UicR2DdlZ/L+vIn++VXhb+mn+2KBdBCkBwD97dXU7evwPf/mXhzZbNbRhSVr8rWwmF6PAr3OkvnVKJPzzOIgWDd3yDLQsTaazGUg4/JPEH1cWJdn2oUZRO63b4tK/hdbwXkYSNGl8qE5NHVotZV6NGEpJzXjLtTZm8g9rybG+12grdoj69S8pOUDC6+u7YYXGaPwckKNSDD3Fc493HhTQwopEORrViTRMIm9UZIaqFR9gj49vO26jVyj434Pzd89HBfT3GLPHMJnRiL/rl5igaQmL2hVXFWXQCAQNYDXVj6J1Mpv1FpeOrCy39oDzoVCCJaJc26Jsy4930OYKV6B2iKFjt+p4QZZaG/npCQp4s4LeoHt5HlmuNwNMnUUeG9uPa7zKSHVfgKSCv2NvOg2N+YfjKefxDW7A6zOgetwboeZ4bbSJpy06Z1JqCpxSSz2iRX7U2UghRPm7swszeWCtHeLSweDMqIuZ05M2lXHD9e8d/LXcOW4aoOJ/BLAfjltynt7cyTKwdNBeVXOvp97xhBGb0OtqhD+CX3sbdQVcD8Ve/nUgkrvTqmUJXq7Z4b/Vacj/MSCHWZCfb73a1Ja/mOT+azhIOsZGMir0iJUEAFZHH8ZFMMAIEQkiHOYW7Ap21DhZcD7jbh/cFvDr2ImA4mOkrfO45c60Xmxk4VfttQ+4TCow8v4+9Wk30zTf6/6uMapNqWzvFitHZ81NxTrac+QlkFjfW+Xvbd0IoNTztgm1eCy9quOepvGY6Xl2FYK+Jel+AAQ/yx3ov0gwPY2QT4VafKCuADhEgtwZP2s++Oj27uaFAxlcZ1GfUhyqsCM1DbP27nN1OY3SBtsnOEL/352yMu2es0RlLLyYMMCneCUWwLsrCFsVkOTBUPrS3bR+WiVxlSiEPZue/q4+eN6cIBCTeUBJF9o2TWFHK3+NLRyhd/ZOR6s2uBz7VJCXWbzdIFkLPD11Pk5YJnauUAzqzVlKOhydyLqyeUH6KkpNNJEiRBetQe0bRRnvtuW0LvZBn+LNxTcNPp0JQpqB4ZL6QgNVOlxC3/axi1Mhh8RimL4crxCipzup6CZcBEKqkIL4c3qkijJF4tId4obyJq8wEYLQ+DCI8On3dK0QCAOt1CZ5BmWwswC17zXrqzCDVriu5ibgkCUCJjn66otWy0swQbe+9UZZoScysNL2QN/6oPwoqn5Xbka6MkWIe2eXe2rSIDK8H75qI7uCHwcDv/J4ofHneOk0hpMmK2Ul6WsMytIQ0bO5TTGKKrgc8r51Oq3iMwJbtcMaiYhcmDRezpmvwf8Mz3QTWp761cpDcXtSMY63CLkO9CoGNhY5KEEtqyGgQHCgzgrn7LG04LoZzzmuSqO48NAecb9woY2OOFp9I9em6q7+jY+wTbyh57GJDLWIm+1ZljaBGfHj7rgSx/PXvcrr4dTEWFg24PCkta6UZUkEwOSz75ZJgqNb4nwjHAYWTrz2yMr+IdHwaKR9eEytm5c43a/aXQQL1l2r7f5n5CwJqG7i42LRn1g4vT95U9cE074hyN7lRLPA9pTdqJgnJnBZQD97B0q1eAkVKRn9KdAqVEEez/1Hh2Ohz3eAYYhOeCItvsXIjclP0sKY291qC+rWsMX1hsqvN50PqQfCnlYE2/hZPQYHdD3rqIuiy4YgqErO86g4FKg1cW9gH18Hvlx3SH/4ysx9c1BEjE2EvWkabcaP7yLJnCuCyQv0FVuy0h+nXxOZE0F1nZPlp6eiVXvp0UKWNBbArdfVBvy3PmfHjSrdnrZBSsAAJ05aLL1HUzV/Ss3pjEjw44tobdM9vkh2gMdza15wOUcsumbrWN4KcL6K7jJfk49sIZD5pkkhoY2WVfLQm9T7H5GGQedk3Rdf21I0PMiW3dGABHUGXeSPi8ldVu10DKIz6KYc76pKcRCXTGger4jnkfgT6F7aod5oh1MVx91COzmeGPUJWrR9OFh1ZLy8HuUQ9OkCkb308y+3Au6zv7sAvwJCNBr9n/r8djYfFqff6gkKpV+Sm3ZWihXqKsEtzt0mp5nbTgDeXETFVtF7ApSDrhk0MkjMjkXAjKAj2Hp3xTu72He/Cmv8AK7eLICUp3c0YysdXLaxApgSzTVSqyoay4b1Io2u2kZQz3s0R525vgMMEtd1QFAEl7CM3+XPOTMU76KTFL8irUsy3lp13NYZRJflPUuxzkiyfdtLLmIeNZmMyyMLNLQT8Q+l+93YFi832CRKHHhqHEC1im48sTqjcT7m1h0HPmtcuV1IBU48s7i2uNKz2QRNUcKRf4it6d6VYOAa7Rr7twWl+HVC/vmN6CXvx7gA36bn2Kf7Q7REWoOP6Bg+WlPYWNn4RM+UOt5TWSzL529XihtB4gZ0Lla/TxrBz5CGqmwQIhnxTWkQ1zcnKq3hZVYQ4n1iYQZZbgBKznWDJmZKuKjeT17rSQlQ7HYr82MvNClsQgbmIzvEc+g36GGWpqdc/N2CrEUvm/J1iuFY4OCG2VivrsiTOTw0WVut4sNLu1iRaKDVnzDqphB9J0WZQYSGsM26AoCA429VCYHKhkohM5Vu1qkH+HF+A8yn0bt95SoAimOzepMmtoTUjzpjSBMIryu+QHHn3anQmFiN70HIwWuMcsN4vjbrkXvcKklhgrmcSBjAlvm6hDML2EH8k7afl7RoRRCz4yPcpKYMAHFkCDijr41pOIyHySFYc930tOWRWWrRGk7s8Q581zn8pUc6xp2yPw4vfOXogWkemElKtX43YHa8I8parKIh1Bt9hZvk2kmq4Gc5KHmGuz66tSuPrbv56fVkYGd0Q0Mi7khpTaPZrbQ1f8nH721Y0XR3mOAFMyg3f3Xn6PmHvOlpjUKxCSM7kwLRC4ftKYrE03j8SeDO8ySgV8EAi1UZV1pPZmwClCEg7Coa6hjZqW9FJpqqE2SaGopPZCNDoEQHvm2uQkl1Hnf6y5DUB/mrJjh6q9HqryTcdRBdNM0t75of1V5+13ghB03sXOt/trcPuxDzb7S5C8HYHyMLuw66fyVELdq/siPHtRzvmQYFGd/Fko4/Hyker6eb0I9PSPsi2R/0jtzDgNpe+M6hHmfS7YBowJZydT231JXVS6feyTm3OMS8K71qmEmuzKccwuHTtvq3j9u0Y3xTSyBs7RiPKuiQ1aBbUf33kIDWGZNS7Kh4w27mR/46yEOaqI8W1WrPel9GMBbhuF3OeUJMHb7j04yEAzWKVPd+JXs4GIbzqSfdnAlmEO4f+W/WhZGisOXJfHuvTBnU/UJcY2GyEaB6JrTXV/z6P7zp/8VaQcHcyr0TY0ufyqCrGrvCZnovaR31ZY3RsKcx5iGWaU6NQ19Cs5rsPvPmlLSqbhAQB1J/Nl31YZ3f7ELz9u/b4I4q6yzz260pdNiFHV26HzgfVo2BOZ6DWzqnVDxrrnsNIbgwNwrqFEnQLicrByM92EOOWqO4OFP8z4z0dw/gl4JSFZNm8Rp6sn0oXpJQIhLXgGn7/oSuTC4+Cz1GOtyYduYpZnmH5XHLkVPuBMt74t9W5W7zUkXP0EtJ02wdupN5QPyjKTo/x8Jl7Vmtn3WKNCQNopgS/uc855HZR1zbtqO2HkyQ2bj6NxJ5itF3mexOYksmdpCg5tgaTUikuZnIMK7r+jm2iM9kfQpGCkUlmnBiAVM/vQLkO1Pee6VIwTVb0LId6SMx/dnRedV6/jCWi2bC6CluEm7RH1gP9Du84cFWHqWuHPyGs5M1IGTEIf+rju2xOPNNcfVz7qbmJPVGXnRpN4WySuyLc4jAQivhJ0bz/fa+mc2MIBfBG5wf/u+eFWwyLt2Q8zLoEguKLTtruW2Dcv7DzwMriDxhiR2DX2NhfV0F+KAfGGkQCypMWQ+M/zYzwV1D2L96uskvI71PqErtHLMq6gAsUoa4Gsb0TRx2Sdr4NLmzhdrhPwOvOk0AGUXJWtJOjx8mMU/X7glnB1ZWUBVsg0YZMYxXn/O4e/BI/N1T4efDK8FbLaUW3qoBwEEj3JrpZLwOa9X7BZFNLjTuTpt/XtzJAmL6qO+T6gOji007RtGf7tjhANV8Di9E+4TQcolOOZtrtVE8SLhHIlIuHwkO6n+ND4ZYRFX0UKEBgucUr1ZSryOYp5e7OiBtVQ6+Eu+SOOs2P0o14/hinKtnCSB48J5KyRw1V5ywNMnYtCwP4vbA/UC7G7Qxb4yFx36PQac3xtvFjbQ8fCiRcjN7k9Lv1ltlAJIGqnC8SiiWMhWVdpiOwLqW1Yy3qN3oKfxJdDM9CbkNvqO6uyYCzMF/pzth/4BYn/WeKTvya6YLxi6mHAaY7aa07x93M61u7xavyYPEogYCMojX2eGyYwkytVIlnWo2ubK3UZ4VEO/JjzzZ/kIjuO3DYc5W/PWs7221OIfKXw89pVr6ps39Mwm8vw+18cagAF31YYnUDMKMmFvbUO0GTPtlTPf+HMpzKGNQQzXFDj2pUpkKqGWOM8EnboQaUIhMwUejnHS/5+tBeCxJsIEFF/YK1keEHDhr3V3FnDaCvyTb85YfiTBk7Y2QlyeAR0aSruDIiCZp9F+lFdT2h7i2A8yX7Gb7RRcocXLd6Ynp0UGT8mbfT6NcoMFAEAD9OVZKWHqLN1oLvmlL/OVu0YPxAyMM/KOPTbKVjNc9nJGF4WHGxNkfxsJg+UAVmkTMN7e0060fVB0y6GyCW9Sxgc6Xev9qGbRtQPtlkS0CQu/lDdbaFXhqW6JD5dkHSebgYbUD1z8y+QFVzaO+ZLd6N/D9IUJDV60R/RgvvKRQo+o3pJnfGBOoYpAi9XpGOX5Ofwlvr/r09DpERdycF/NjG16J1Vj6DDx6wDji8Lk8KqIcMTiRLWDcoYsqvdgn0iQ4zXQSKF6gQUG6cqQOYLhlOxq8k1SsyUC16GSnLSaAh9feGfiX/hWCNTUmwM+d8QArCBKFzULrZBut9+MuF8VuedoD5tyjtGbXWTfe/ZmohNZWoceC7XHdhTyllT7qGfNhcaBf7YvPy6KmvJpytrh4slFVtQoX0eFNbGs1maBZH5YOTG+Xt0YZnFQ4hwzE9hs6ea9CXBi2lCJoVomRqZTWhkkmlaFN1NPnoFzru2slw35Wk5yzj6lWe/Ilcl+Y1XxAa0bdfS3/VthkOJK8exn0AO5ODK4xi26Z1+TTVDeI4vUeCQkBcmQwloKV0wZzMtJwjpgfvsbc/HWb1fLmH75Ih5sbVwxX6YHxBzrD1rNmaQsSS2gBbOUFDzOUqvAgzkm8+n+MT3fh7XRfrv6vMNKbHg0xTkeReMVUryYS57XlGOOX0moQ9JjpNRj0aw85ssqNmNjEVtr5px8d9SrNDpI3oOoiz+QpSjtX0QXkum5ZfQ02/kCeZNQJ9bRpct5KN4v4gwFT7h4MTbEe7UqGsMFEnv1KqlRlF+7vw5x8HkA1963qwnlm3xbOCOAcrW0kZGvLGU7D/EoGuST+ySF26bjutllP/hPzR/YpjJswUPGK6fbTa0DnbhADfjJL4Slf0RKQn2mWq72w675Jc80Go0ApqeWfiUtch0hixNBskit7OwYA8TRPtp/Nu/U188RtZzcZ8+ZvefnY8SMKSlmQDsPVh2UmQSt3X/U/JxjUUVReEQYK/UZDlVBV8SJV6eKdaOjhu974/gF4dNSdB/H9NQnRduL/gHLLsW1dRrLte3aL+DHIrVr4AatuCuWhJPaCBpSs2NeiBV3tgXPnQv9U2EC0LcKgAZj6+hbbUAsonOZ4zWfey70IDOkp5jga0eQmOMrNK5JKY/nwYn/LjkiHjz3c/kM88keejUR214Ib+o2H44lFYo1CQ/18iJ33NAX67kmf0aqM3gi6QbJVSCE1aq5oX67fgFSWebTQhWMIwAuisO0l0LoicTR2NrPsyU4LzTVzzyBcWqda6qM1RaJPPPEQraM/9/pO/k4CzU/2nq4uYInHMBrg7yRWxDMtf0RQTAOaA4EFIhX7u99c7koIdRBwj4D2cTkudJctdD9gerPi1LFIJb4h4/NRfC8NwDpvdYIvkLkXfVCtepYrvvB4D8DuDxP/ChwjG65EYSFkB1O+oBsI2uLB9RdyAkBNZt+rNwyMVNQhphRWD7zWgKPtn1NYq55S9jjdRfQMS4tknObw38IVst6zykJc/9xbvsWapA5JvGkGVEwgyJJKbVaSX2S7G/+6Nv/APhwajUJm8fFJNFJyWKCH9/uzfCQvOVo3uPyNgCRkyPdrMd1M3inmi6hZHPF9nC+qgTS7BckwAwzrD1qxYW0UnzaAhn4UlcPfZbmvd+i4ZclBOI53ObTqZmHdVGmjyoIgXWCLN3NgvGKNX4AxK5t00TSiOgZ+QNn7F8WcX0ond/iJ5pyoW8/bcZrezrapzjSB9uvpzuU1erQ4sB5ijE9PwDu7IeQByym02sGWK6oS9ceMdCePnkWSU5C/22hykdiYjMwkEWkDINGGrjEiUGbDB2zgkOZilao61dJvCO7hbKz1uQ3Ei5xfw1wtg9zI9wAwUNWIWWONXnTHfuY/r+q42Qwu/ewFj3GhXpk5KCFFaev3OK7dRYhEOpLH81K00VaYMQuRzv2mypZSSG8CRQKvHjbR3ejLthn/rM38ZmmsrdsIFkJdDDwX5/+Hm6NRrjdgUdeplLPFi5tNekccO5T2/oPYf0tXFfNlcvjWkjdKynvpunfSn2whka/E8GpkvvSwNESDDOKf0QLLylDG5pZSXRO/p8rkHQ1MlA3gdRw+3HzK0ZEa4+cogSynPEzmtRLsHTDYVfDmGrim/I1Rn1GZOmSUqKCxyjcTcj3VH7ZiuCtD4gO+d817x1F5pbnwAinQvO8H/SbPOmwQDlaXt6mDb1riheL5sG0My9pSCeiNv9hzkmLtigRNHBfrPAn1GANhEX1Y/6yMtsFu0zhGcivW3WausK7gsJ7BOaHwnWxhgNC1TP6w2aCP3HqLdEVgI9LU5EgAzO1Zosnmc3q2vrjsaPaDttg63uXkVXpy07UxKS/v9oUzwpPVFzgcOMdCuPR57Xq3aV+CHefJKuDbG1GSd+A96R4+Q1Hzpq0fpZXujRSK3uMv/d6gyZ71EpmH6Z0EP687woiGuIh+r0Eo6h3pegBoM76ovxAiz6C/sIu8HkL1bP/YaE5i8ov4VB3Oaf6xeY78ClHiK/4QAXcwqBIYoMuau9n6YKCcvfw2HIjfNpT28XBD/hRIBqjdiatj8octwSDxQvcyxSGS1kYWhKj+/FxWXFXItgbFmVD3CHyyDgSeEt6e6W3u5WDEGe/Wx31rYPXJ33C3ezx5LHoafGCjSGY1bElgLnGudhQVn+r6yTU1vD/YHM0m2sFBvv3YRwg9IDKftU7vCrPRq/KyKJgVnMXjglogF84ZY0vvERG1OPF1yum4A0KYNPCAF4XEUd2o289RQJDTS6NiCnALGH3BOEqyFayB5FipWs7KscbqseSKQvJfUBwsaz/sQdNGPIkvnvtBSePuRazwKUqKxTey0UHwm1YAKPRQdVndFSQs51LBOELgGHGXJPQsDRxqMb+5vg9m68t4r77jaE284b8nITho7Mv5xl2qeX9RjdA0hP2/jB+rAERUkHcqilBlHe88YrzvVYyV/oqddLbS7uRAQhT5vXwOJR6IZtmeC0B0mSpXUVnL/mvTldc4F1xHjoCtgv2IyH/0QauMfjtrWQjCjbD1VAiZpR9YhNYS65uuPjqb3/7+uf4dn5hq0Pu5t/0UboADnhZ6tsH73JpMOBl7/098T/3OZSLGNufVmLkYkjhLIdgsu9azrTEomi3w7Om3oGjqYDt8DEaz6knYA5r0Qx9C+8Z8xqqUsE7LdtC7IZQmlpwhQFyXBbUtFuN9FJ5vPWtKoLhAkdJHlU+SGDgu28V+/btOWJmiNnceECWH+2YQlALA11SZ6LXiPqicPnO/QZ+DZGyHzHzpRpy+kzhyTMFkFU0eFjoL4u+2qyxEouNAPXRmlRNlKUhBCWDGLR4LhirKtjCGelWJvGQc9YhF5VR89PVnGuzz08pxVpiMYupz3k4R9235IOiw8Pt/KLnRl9Ql58fyR2Pbh5GkxbkahfTicopuFbTG9r1VgEqsbRN4hLt1t+++wrE/dlwXVGSkHgZN5y2ekPvhdKY08CqEL6FmlGGZQ/GoOLjYvk4DWuGrtj6zxRgSytECxiejqBRnnLs4LID/UNJqQtD+HtyPajLQ8Erf96f5JsO0wsfQchrEDrKxBXHQyd9vj2kqAL7Z74i64uH9faWLdE2M+NK8mfRQM68knTbcLvTl85rHu6mxz0qEcxxnvxTObB+4+1626UyksLTDVnz8Vi3zhn58QMQZ/hXQBp/h1Q48AnvJdw+eSSI/lpAvIqR8lAmPiSX7vNpCGvYNFH+f0NIX/tfF4ljMK5ZtpzEB6t71kMAEnsuDOu5DcG7gi8Da2id9NLyYcAgKo01igsOv4lCWmwNb0bBcmVS0VjxSH/IebTj9yNHqK+3bLYbop2+8WdHOLN7seU0Q7frDm4NoKx+9lwUCpZLNktjOZmhYCf65RDOAgutZr0biWXIztA41OXY4+N6fXcyywAoqhfmAEDpcY/vGbIqeTpD+ICIAG8uIEC7M0ns7rvUNjdSzkoRU746lAMBAzmE4z5Gmdyv8k+7jKfKdKQkWPojNe9vTctzZbBRRN/phtW3dBvHsb2f6RJy8P1Oh/9Gh52xfvcyII3rPoeFyYndkYBxkVtqh69YbKoIJ5VjPFPVeC2ga8mM5+f4OBXuJfLi+Ib0RVaSLZ6+OTK63P9mGjiW/B7sbzPjdsRlIc/6g1MovHHwD7nQp6Y1CvCcOMwftGIa0T6qhYMJtDie+wrvfOSenqZpKupSwC45sAK/NFkbFELNzKF/yKl4lUsEo4TfK1lx49Ikrqv45eaheKOOQPZ4frXNH9Vn73czzqj6PiMpPF0fTcyL1t4QMDXtraxeTDKQcdg4aCk0GBx4vAyY1CIzLasBAthGSUd6OupMiMoUp5opVCwVNNUij7KQhw9cVWCidKjJo6Ji9r2wpbxqUFagq4hMftwBKvCUyr7Spm6KlmjWC5BNdbRfMebNs1FiQW7kxA287Zgko2vLWdeeZsQpfr8eA3pxYY017cU9vIrvXqgRB3sDfusck69vrY2kqMx8oVVaDWOwMJJEuT09rqMT0eiJYJL7Axi3E6fukbZthEb5NRudjw21HRvtRmE54RGoX7AzqjtwmkSrHzlYZb6SX6hhA7LsNxeem5JcUEaRfKJ1RiMdP2VSb0NtHp6tK1CE384d1JO78wlkrGGBslK/s7aRgT5q4FZRUmPt1livN+UDV+bfGCc4ryFER8UQlQIED7Xdeg3xCZwtg3dCDV0cvLnAV+EjwHxAtaGUlN9Hp7oaSiR0DPYH6HwvvTArhnO8BrcQ/KJ2+xJ5CWxCGbqx/q8kF3avZA84Vl1XHAspmITfQYb9qmrzx8ij5T03ymAKc0ZGq79nbS1SkyOST2TFnLT1qcCYk0FrpMETTr/V7m0PQRbflaUWGI/Vnko8l7TftDULd0NafWEGzYjnxsznkQq+5NIutz0Eno3ZJRjSANQh0jr3o4RnD5KusTL4odnyLSby/3jTW3jajFKJbz2ndKx9Wtn2SG65CkpBlMuWnSwTDdusRXWm7gizFKgtlddM7I4jXCowKLXn1O5HWw+Jzx6j5WrlQTNXArNC+3oE5WP/PQnr+tFTbK1Lw+YbR9bo7aMiAZT1qhTcali1ffN99Y7Yjav/CvgX3oQV5zZU4GfpcqLky7LWefw5yJaKDUCH7BM0hPxlbkGBtV7QJS/7q7SHuzJ9mhk5yr040wUKqmRUtNyJ1sIvdvCPPspWIfuQKSkZB+ilg4qaNfUYVXsQJ4YKeL+Iq0gB+6wM9x9n3RIegECOI4v5F/PufdoHbTZmfMeJwvLOdArHfGXTdnf9Yyo1xV3spMvCRprJtjjiVeFEJ3PMPyIFVoNoYS489l0DtSXT1zg/BhNSLzDdsDwMhTVlP9yLy8FTxTTsLF9tsEnec5RsnI6vnOr3GsocYazAEeiueQk5btOYMvQTsZlCSIQY4OsMG6dh52BSjAylJ9pnAS4jnZUvWPCMbluHIou1JBlAsEHbWU6SYsj1EBmf/MY/K9KzR6wEZXcbc6AwoI+WVZVv4SCTxXylYzARjHdn4N+THKNNkl9YUx4qIY8NrmkNQQNiRoljlzsC0ll06hx92Zg4Cn2nLKPlVuidSSPRx4y+ZS1oVOInsZQvwbvTjwTtfJ5HFPIyN+2T2RvjAp/dr7HbtV9T/RhHDNw8uTFanSRe8zIeGfBKqU/iV+ep62X5/Eh28RtYDOldiNSWwmHX06CB4UyR0TzZkgeSHwkfgV+TZTuOWzHfafKM9wQ+3y5DtTDmCLMOwqo34mJQOPTZv5Mf+8FLDBt+ZL2WMX5rmiAkpHk6Tk6s0//D4oNZPmoyN8swxXG11Ff/LnI9vNWWhbUG31co0nUq7zRb/Gy7jgB8mqTKm0WmmBhUKzholrLOZEg98X2opeUSledX+6ZiBVv/ageCT+aDWjR/4D7Zcyj/SmWSHvUYenUVAIjq2C7CAcfBXRteB7nveTG3wx/WKDCXyYpvTB+vM1rG/1tys1hZ3MwNY8aF8abKxv0BUEaZPHmvxAVFx3dnCVWHadRv625OCLxWgPvL3OrI1TMY4t6Wy7/X75bC6/jOpxQDw2ZuVVXs0e/lBEEsx/xnOCmc320z1m3hjPqYA7tYGnEhsoT4irYoMEw0m/Gd5TFH4R7/gh7RkULAIYk8PpIF+OpdQGV0c2ImXZfsIX8Yy88LIQSC/LiOdoyYZ+yYk9U4oWIX25EiIHHaQWeeiIhkGWoaiYaM5S5WMOYj+DwwFSAAhDZXW1LGOdrAYX0jfvn1m8dMqMaG5EzT6WRu9jt12tsq3LrowwBM6j20l3El+L9WKGOlqlMy2uLg6+9HoJX0Pbg1j1hA9AbpjNxnnX5L8crATOG5wGKXQvC4kpkTn16xQrkzi5Xyj4JQ2jXwDrHeomXfBPL7aP5bxVQd8JiS4EX5ep1dhJZi4FzQj4wNEw6XXodRITP0+Ub/X9tdepB2/WcdVqvTO0P5uRfUFR23RN1j/VNsl4r8PPvCk5f0ULYd1XU6+0ffT6+MbzR9o/qtKvTcmThSxRLoRdB1P+q1BcJ3yizcx/RA69NvQH4mIl4VhCTa/A5PbC09GrBR03i2hegHizwCiS0hTuD29vZWOjEgmM4jmEClzM/EG8UT5jqhCjl7jIhzKT8tYB6B94TLRreyZHGbSqhgjCaguy77BEfnkLnTIJjUmrlppl6Bt4hFrtbgXq3nRQWanmJZHdo0/qtBUh1PS9arJaj3idNxYyoeV8H8NyosR+VmhX83eft6VWjb2q995ek+uUApw6Wk0Z10I1NmKlvzrk7TNC+p2JVmrWDFWMhozs6IWMyPPKj2iOW/7U5tDIB5oCihBRRfzr6XoGul++zvp58a3IiKwSPzFhu1Lqb5dC64JTuslbG1/kn2wzr5KqIpCpM0Aeu8i+9KszkipbclmmW/kV4Zi9ryD85wv3c6hw+T0X5N/DVAm4HC/KuPkEpG5yi8nr02OXhGLuL3Vfiqexnu2GvHM3L87m3KMZum3A//I9TdkmelGDVinzULMhvHOWYGIq6fsSLS8Z1nqzTWi1CjEVl/gXUU9z2AdKubtBHekjqWTsq0ao9+zno1eOu1c5YXaayRyoT72s8hGd8kn+xAIGIUcNV82LgNro/q0lJevo3+u3+eOM5yHMd2CUu22qdz4WCPgRoslwe/9wnP/a+0ZGs/ON4KNrvSsGBBjAXG/D+ak5oieuuyJtlDenqh1ALK5z38bzgW2gQdFnrtSJqpQHqXTenHhskAZ4v8PGGfEvQqmjJ4OGeZ9f05iqGTb94DVpB/wupfCCAtntRs96KTsm6YXWneEiikP0U/NDURQSl2xzp6eWm5RTCInC/TPUpta/iHFoPZGtEmVYr47+elclfdiB3JSaRI6iMI6hOJ/9mft0sg4V+xVDr4MdHea4xI3N7XvsQG3MeOQ6UxvLx7JY4iNC3N4+cezeR6WmppkRZKyfIHsChBPxUFTloXg3bBDwgESU0X+IaLSNv5MqcOJU6z2KFdTVXLJYpY5V4Yw14Hw63ns3TjUBYY8yChHifQTRX7ehAhyckCKfKOveca56Atf83RSfk9v+uvysUWf0TISxnIIgvcEgznGSjfMa9GjlluuOeSmcKpKKCcAqYojl3vPiHZ4j9oPQRN+w1lOOwEkzhyvPtJQa00HAuXGM8h8CMK+c59qg+SwL5q12363cR2nxfrfl7n/rzSZD/TTdwCqFghj0ySKZEGrhrwsdkzKikdmQj1kYXV14BLpn4oxVLsPFn3k7ZdqZTfU/we5nu+xkf0U0oahJUBhHlnPxgjrqEn7ARbkzAI/477E66zXAkBs4E/Z09iDcW8n9qm1kvzncBKOz6Rsap9wcsxgoQ+jXxOMwIhXhagwpHA4zXLq5UmelfaLx/3qVrjl3Sarecsfpgelmf0rHRyGtsYC1WiIyee0qfhghDa3ufdb631KiTH+lPqBW/h7SC3TnNmPmcdJ+JCSaIb16j7KeJebGIvYOvvzi9SPqi6VecJNJYoCo7C2iIvvnDjRP10XgNoLMDXODuyKUjHMGerUNry+RCPO4NThO0PJdV3x5jnvq/dUFGlSfc51ZyNfLH9nbSsYMPzf5U0hSfU412DJ3tPa9EPzR5Ro5ruAtP5apYx9cHc/p2KZEo7zuWGiAHHr+vXrXuRM5zv5fukuu/kFzWU8ovM8OdlN8OkFLtN5R0M5WpoZUTS8iglJxFj3K7yONHYSE4TDu4CSS8qis+zM5WxigW3V4T/YwSTiKLk2UATcXilt+YmMmNTG7qf/1xHz/+fDRLhs2yM2UCfKO/9DaX0BbIkHgcPTwufdaetL5smffvdUctH7V3dY5q0IeRVbmBXj1cUQ0YGmiQf1N6BZ4TDKWly6uwBquL5V2b9lDXoE0vbc8EgPC78fseYwQq/U8ISPNxPaxiqZz/SiC1YvMFYzw8E+aR/1T/u+54XkyIvayH6AvsuuMo1kOH8NFKegn84RzSLX4zmgWXeToiALy5Ya9L8KgiioJGQTM9jUZIFpyNLHKUSgLZgvF0dsjweB7PSp33Q7uFXZZnGHD5T43i1tDOAr+ihCV/Pue7qNMC+Ruvb7U9sKxHy0uUUZg8Qu0c75d63tOf4IkZ/K65CW7auXerrARaRPN42qiARjWTdEpUqrjVKfMU1MY9zDGGEYnwOmRY1aOfh2VKisWnomBcEQVTzzmtitowrJqhwAYvs5mAmI31Faf2nkuqUOeQdlv9LYJUhNm1BJyixFSA/3JhKsp3BMc4EsBiD7mG4ZRxSVRU9b/GNzh+oJKGV5LlHYeTiYGdttyB8EZIFwAPFPYsJZOhRnXRClKoO2FXeM6h6jmbMuEGGhAaroNN0coN7XeLXNHKWegFnYnfs6wwOcJOr/rjjc01SMuNIZVR1vNryJE1j2z5yESdDDxshbe1oX19bWXEIIYZejcjKdDcyyHZp2EEgxWVCzkY0qfBcy7R56z8W+dUnNu3cn59WoBk3gmAf2vhDVnBdBADQyOMBAWwYhIV27moWpZ8s89S+zyO/tGcUC+Itd//kjuTbAb3vBc7tBN4FTWH69yTUGqoGHJvb3z+/wYJaRHeY9+8UMSiKRN4OCXVJfquPicGqJ4gpSe2vsF7on5QoOy4vo+MMN2CbCcIbBp/lOJ4YvXiT8e1B2xQXuB9od7V0Z7nWnc4zzvrjVTKcBIoT9Yex6wQ9Yvkv8rLdUxUna70IpNKOgDaxE/J3+8qIK23yNSr4ySrQxThaLpf8l0fHvYTE13izY08Hu18H7TCsB1cfJ9IVF9igw00caKH1UPhO5/3vsDcBNhJSGb/BVdlGTcvQaOtkSXr0Fmn2WZLKexeuRVJvGOs79+yqvMHBJQ4JcfMb5XFVim1y6fROLEQJsAZJKtqhrX4LsBH9DVPu93FYhuuYrXPwkzryTULGyw3M7heeCJn5a/oBrIJsNZAKaNyhkGwipA3QOXu/PNpmmeWmfiSymQraaciOQdmS/xoylSv3KC2kNEkoYu6ttiSDqNe0zcDq8Wh/SV6bTiWrCH4NIyTK+QbDrHUKb7dekw16mxyL92sSW2wJM3LCxhGfWuSWAP1lJJkIf4+shXJWUsocm5Be+bQsw3aL2k4EKlCD6Ia0Z98uTnNBeDuZAf9c7pJ5uicYCkAuC6v37AQ6yFbpf6KJm0TH4TNFJ2y+CkOCyZFYPnf9HQhw1MmB/2SAm2nD//ADvx5f5GmNB5fwHYDqDVe5fW9gJuDGzzhJ5tn6e6an0kPr1qEPUGIR7YwRb7c5b/uJqN73PJ9g5dCs09tH6gEvoHM8GX8YE0BPhgmPZqUbiLs9+i3Ze+Jb1rEFYTL3ho4hagCe4xIoxLnrP+V6m74mVgL5NqI8v5SQLxLgTQgf8g9jxFT+oK6ehjyz9D8lTGWnbGOs74b/zwtwx/m2BzsX62N0asOTAW1oUU/Siw2F+dKvEZ7SWTjGHpTp1YyqDuvg4OcYpexrIejFhdnVPyXVOxO32JdsG/H34sxkb/12+D7tUzj0uwciKXv5GLMdWOvp8KLVFU0Evn9N8CCuWMyWNiKm7vcZR+h1edLsCTx2cNhcQG5XhKFfkYh6TpQ4BswGnWhjDwu9ogrknEXZ2yDp2p13PCTISFv6zK7GZUCq8d9PffHkgHV1mwhQowfcBHnbkbRtl64vcZqO3JmupAU3/vTWGRwIsHvG0WQ0ukLvEdxh+Ra1E739d22bBnI50T+2JNQ2oqDBTY0Naf1x+OblgETS4PVMHGixXSHOT3bvpjH4p3NoTTvB0doP5ZJCkiFYoaxrxN0HZNB0j++fRWkLOPUHuMsBS6mNE1YHYYdFpWibrnkcwIrzYbCSaQVoM3YgIBVal/0ASnQAy6jXmDadgflkmDZyO3taL32E83bvjkdWNXkCn8rw2Q9AeGzhDB7GWVOwYTya97rkxICliHe87FyH2943RS7+UiZwWW0ZimJwhxDdFSJHI4HO+RAq4Il8KzyF8VqEH2rriTDG+48iBDXXUPU7Tl9Cz6rMNdSVxQcTDXNvBl3gxtR0VlfwhEGouY8uejGaYZR4bTBtG3Jt5BdSdEyJDtnI0RMzm6QZhXaMKO4WdwSCpY12kb1W1aWT+4anfWf4eZyYzRIa41B4xdpCmNUVX5EwHa799xww7QbCPVwaSDtDD8YP/Q8MqR7rrBYJuO+j6GC4azHHkWA581D6kt4rXprPOkpZwajJ1zLYVlHxxXUyonMUvLfWUSnGvSoHoujzkqOU1EZAbYO4wlw+7gfrGriBuRPv5VHeqfn9QSktQre9I5ckXKvZ0C+ZwwYGszfvDC8sdFaIwO+L0BbpSCJENKKb61MXq+wxLBe+MU3gTg7coNj/c/qdn472WF1Ela2XnytOfuarCjvbmw7KnFAwD/RFeoGpLUR3eMsDWJZN28OIyavnxxoHkwe/+fTloePfMlUT0EMRQCSRyf0fy52AoKOcvPiwRduKQpKvDCaZx7SpVwpTZG55Fvuje88E2YA1mAZFkA9dNj24ekCt/ftmkvUsFeiFfbbhxnGpkmNNpN7jz1d1OZ3EXMfTAOIoIm+/Cm8Euq0SjaTLgZeV7M41KYXEqWBbXIlL0/zLK+MZLmwQLarS0ow1T7OcyT7UKgQ0mciP307JtPVB90gziCIYTQEqpGo038VjHMWEsou9Rk2+JYtZ5/JW27O0jLKefdLMd0TMyRMFpGn9cMeHxoAP/dysWkHQRLP6BdjXsnX76JoJ9OuqNS5c+hFZOMpWYSwdo2iqpcSjAJfzQ03g5K7kkKE9pKjG5w5hhGnwQfW8bq07Vn3O8IiQwlsNVNj20At3RmTuE6CjhKKvnW9B3tPHWwTAkxb7AgAr756FFUP7n3cUrKtGUGaV6u3uzYb/f0g2L23bdNItgGoF4BcxDqLuKU4nP+tGdyZsCU3Doae224ick4rzmaujQrXe+InJF6++odqTG8xzRESFs4FqIzhs/AMUQGMD7rVdacfG2eqDRnngvatvQA06LuKnCvC08vnZkOEraTnS6hx1A5DpDV7ARd3KDsQ6MKALWedL7Sas/PTic60E7nevpyfQ8jx4txdt50rHV2Pwe22qFCtILUfFPzSS3fasJijM9f6Gx2JNFGQbaODyjnseUmd2WB7Xiy2GsoCKhSzSmVW60BTySoVRv9sEGLwOo2/UZZ/opVoj2eknRx4QUxYtDd1da0AeyvSqNeCUpgrPGG0JFRH2BB7M1X7U5qlIQ4krR7nuHyx574ti9eZMpAZytlBqa030zkwyosdvmYW0+EhdZHLcr2YVsPVd5RTKc1Yq+gpkyalmNkIlWgybUFRFsG2OhCDo+905mwlgC1f3lq7DFhjDT4UxNY5fmPlDMNkSig/oIuMwtJCseV1p3RzG+9b0gQWdpFkFD7wjO/+1fdxZEjd5/Ty6/wzxWAmqBD307xGVztXeEro9VEInqQC3IgVuNid617zWgih3eVycbQrZ81at8hmh24RnLNy2kLnqJv8uFUvWLAeDDmP/8I6uOH6F6H95VQm8+IivO7e7iPtkv94xgygcefitnxEyfCa/cCWP4yvaI6dGaig3StGwlIUHrmgJj949XQkIDAPM2ofDD3FKAos0Z+QsiLhUCJSlobYkKSo/Zyz7ooCLKnTzGvMl1xswWW29QmFNWD9q7ZDUKV03NcPfQBnfo4rQyK64CSStkuRVcwBBTkDYWzfdRkNhBCH06q1s03FssBmgSVYNiXEMgTbUGyYUF9NvPL13JRDSYDFm2bPyPBDIMTP7V+2ODIdG3iTCQFnuys0QOvY+bIvezaz4JFRI5pyBKb4RZr8cFpv7kR7Kin4AYTp7pdVS8v98wEv8nlOqyK6eEHT7ltLUhU82YN+Ue4jNUSyH9cRl792TmDSsNCUQ96/ETiJ5D4+AbbwokKAYqmK+8Yy060YkOnP3yQNk8pwSDvDHZyjG7Djbg50Hl71l9wqYFhcTmaXFdZzaqEhf18M3s1MqxDHMYoWTM4S0Q9HK3395XH/hzuNDnhpCpaDs3TDeRrDghS9Wq8uWZyODJL+0fMrTSEy377D1Nqywb5WWUjYop4wVnjkEJ+rW6PpMP1F+grTmy4aX5TT2rJ1Tp5d2rzmWTa2YdmRilr0bOAAxADgByem7YSdUBhz/XQVd608GXgkFLqLLKn76AOblJzdpcA9UYiKhY2NhW2KYQNb9bjwGU9Ubih/nLWoBZocA/SnlIzo7urZvG90C5nsYMoO5EyonuG/idLJMuVbusVOhzqDIHfJdDBEYeXDoqsiYTqU96EpKidTZVK3LEHOfGVI2i24xn7uHi/4ZKQ8TIMnlZtYQpZofr6UAYE1PM0+qOUBzypevv1GOKF3g1H5CG+qZqXacZmiLGXqva4b1T7nAzrpMriA3J8b90v9Rvl+TDd3Fhe3xmXNIKPQguDh4JFs3cOblzlP7rHRSj6dnPrUF4gxO47zSjwSFwjOxoKU1KQ3WBVEg6fb35Kzhv30bfmg6zqOFifymTxRWlC7Um+VVpPgfK0LwwC5OOjNmYyxOoNcQo02ggrD51kJzl+DDEHF+W3OgXcc7RiiMhoOFpdHDAGpgm3bM0eKzzs5JlKODzrbXFatn0iZjqVAkPWiBuZ42g97oH57rA2PsQiMVZp/W9B77YjbciaT2o3Fbiy2ytKSDDai+oA2k6s93FO/rhln5CA6nNcjRHX54/pQtcGGUBUHVerNPNcsAPtU8uaY8ds66QxEN7/B6RBTzL+cqxqz9YEDIkXPpXKGjzPaVPO4Wj1sXdkOa0o5xe3jE8IBbSFuZJOonczr2GQ2xZe3f/tk6kidii/mUh5/8/xpToCuZ+hTBqrw5HlxQTGDze1tUygYjdm1S5aFbO7Q0bUBTLhDBy8SBfkwudg626aQfz2Kwp55B0u7trKz1dbpVpxhsSCv7neAphvubXVijhczY1Wu1iSBgN8+Wbq3pmAuFk5QMQnmP8BHBiclXJFr0UiQ1Q17vw4hhSHLldoe9jIB+rk36uNDTGnZdxpRq3noGyfpisPfbCPAwgXWVU6q3Y20qd1v6ByiBzWmELO5w/qSCaMjY2oxG1nIaNDp/aN4hKvQUQD9p4mbWWCVvBFf7MV0Uz1jXQFJsf//+/NJLOmYP3Suffohjs+oaSTvJMr79q6Oc0iA04MFkOcWSKRnyHY+3uq6em+42bWWCxdIpgPuORTprnEVTLhP2/Q5jcYr47HBJTvknPf8e8dKIPu67gYEJO97fvXdLrbjNK77zD9cbPKjJgbZItzzSymP2dSjMYgEktlICYSpA+IUscBYB9pp9IHGbz8dWufqoOPsZVjw02YL36T31KAC7UdyJXzq5z8k/u70INXrklDopJ0GIy24ghgGpdoKeKI4AFGNTMqGAsyOs95o4mHraSzWv28rJKBwSAesYs59ljtmQk2p6HabZkKXRdtmesUMc5zrCg/pbR2gCgwU/hZOjCKIBPsteiV/bhh9V+z02iTR3Sg3ptGWvtR623OQv+vkRqBhUlv88K2XdG+DRYvMR1pG4VzhQRqFay61jOHsDDfU2XbPTDL/XBJIKGc2KYHmeMtL6iO/stCoeodzElMEJMwUpdAH17KPQ1p/i+BezkTpoGQv2zMnt/pp7JrKwPB3+rX96wAIIXuS3wGz7Roku1i5RsMJ/pzJ+1iLbWXeD9zIc8aOUyI1pinqMj4R7jgjMGKncL477fm+sYtPUi+hrRif48PVC1lhH+7mpfvo56GrpkCgoo64HKadQ9/othQBJwofQ02wXC8L/OggdIN0Y69c7BcFa9hFSuUSF0jil5eqVyu805u8WJGmUAgin7PEFYyjAkjiSQ+zs2tumKrpcbXmhgb5but1142xmpf6ijIe4wYfAX4RW3zCSe32JXHcC+2BnEglyxZhLvUWPL6/r0bhf73Bw2I9aGNgaClBFttUa0krn3joU2e0ti1voH9PpyIl5xSHQwg2i8bLgIQpwJnZfgJ+d6t25XSvIcVVvXsmKbhcxtk2Vx54PgD2qeNArF5z8MxoW3ueG8Oah9YGVHKy+2yTpcdp6nVFqoTb0lX7SyWE9AjuoGX+MMIQPHy5wS0L+jAOgLH7sNSER+NQ5yioJESdVw9pu1nshD7xoVvM3eQLjQf0wvqwYB8L1atsb7ww6Rda2bFqxgsTZj9Hy5teRbrkafvjNfTU2GusO3BRCNTyG3t72FqZMgUrJseEgW1gezc1LJPTSsG7s7UHvAEtYt939nA38Al+AAhEWWDR4va7P/GgCP1+VUeB6wvnWmeJn1If5K5N/UKHeJ7r+EVmEyk43E/b5iKwRxrXYjwit3IXAlENG73uK8GyFZKsFn7tW0LebD6u3/z4kjd0fGd7etrgou3hpbsPIjTrbD6yecAjL52eeLHEkWq15PYVGXKiPMokZvCiIMLBMjeHK7r/EPcugfKd3aFTXKdrJop7OrN743LRgNy7J3xvcMaOSVwMXPPLzELsWZY64FV7tsdlBwdkH7XBsdtTe/kIJQ0h2CADOm491mGGSV3ozqgs2WOpkvbCZ+HWmsIkxZSbBAK4oyW2Uf9wPpyI1Fag6DBypA6TpJEugOjEXNHrDnfWi7nbdRl23SwvDYTFAGsHUgBpDOcZXFr1GX7MgZV4JzVNlqao8gK8lxUZERv0dev07SuQTox+C+a5dYC+7g2C9d1xC2PfBvq+BjjpGD+P0HAWJai9AGPoPZoYd8sfK4CuO0qIi7QH2r09KCAtYw1hRP2AQIVDQBC0CrDpF597s3JDSOHd/RK2xxP6VC49xV+EkRnpCL/BwvdHSy+bH2cGUYGRB+wSHYmcWJFZYft0vaY2XPBi1j2cwAXEH8xx90VAPs6KxCCix6cxaStCO6H4KdtJOLiDKyG8C6pKimL4HDFXnaqgePgDZpIXHaXfGO8DeQq2pybR5ha47doqs88M6v2X0Te4CkeWOZk6CZC8+76gsxVqsJ0Qyo6EbXcczPm0cLPWfpKJXQ/iYKsYlePW6P9+Wh/OXx6FhS6McamDv0V+fOshJ2z7X66kNq6rt99cZcnsT3Fk0IpgxIM2WWml5aDbUFsGeWbElK0EOnW1GnNXJdjDZYQbutg9co8j4XuMFuBXEG+eG+XolyuliaXQxEgFSZa6NIjFlF2KbUPf2ugGkEx4tBZwX9JuugjdTJHUpOerKoK2OXwGlzUPhPI8fQL2WJFR5JaFx9zNlotpmNnONyEtGw7hPHS4FwHY6bypPaiGUIH8zu1kvMhMAsur3QLG+2out/H2jJvl9oyyVbnV6jTyF0axbGXNDEu/9qooPmjyiik875f3i4lM781q/9Aif9pbZFGV/dnitvPvpGnD1yu8Mg6dhgacItLrMX9mjM/M/55icuYwkgJNbFdisnFWeAjxIJGNiK8E9dkuELPxmgC1IqV+Mhc8gqlB8DdAWzRCA0Dfd+72SaPkxHTlrUojKVgI70j8KiEMz11FUbSCH2JMy8wi4XYX1J3C/7qSysT5tYqHt4C3qHbDicQMgSVYRix83NuDAI1yCXNFcTTMN6laur2aZobrqIldvg5QkYRn34nyJ5mvfMpL8c8T+ZseMwzVrH2nzvzEPYb0PL0Uvt9oGf2eQSm6DPTsZFrqN2egxuV7tGW4ZPlrLWq8IRjq2STIfAXrwuPvEoWlCVCmkrrFSFTDwDS72OKKMkOwHRTNY/QEJDGrmr0M52eTJS/+GNx5xnfWnzIDeDNpDJEUhOo5lNafyCp150ytBpC08u7KS5a/wlYxe8JHttcV7J6z9/xHnR4EO67KIQISwhhXnQxRvlddFediEgG0YMNATGiU57x5+wAZamDXPlSji+TNXONAYg4L77Ino91uKIYRQXvJ10K9Am3bgAdCLaEeneko2IFrlAn2ApF/PcroqEyVKeSupHTBDhJDjIYfm/f7Ss0icNBcDFU5UtX9SJA1NgQG5CfTBVBTWVl0Oqv80AccAuiPypQVGOMdzkHKpn9y8GpgH5f9A/lgqxUstOGYb+Xx897FLhNNJ7qD38Br/5dveN6aw6GhYdLliiw8GRe3itGDdl3oVwZnb8densC6njeC/JqIPBGB93XdHXtsPm+32n2dCUxvHmsiICCcP1x1Z51CbA6DWmPO6KXY1M9ILcsPMx1JX9a4CrU4XL1HEI2+KQP52dC+xP3W9P2/npfqCrPnr2RpIojS7cOi0jQTl21qTggtM7GXdCx7+mDecidZSI+OSB226zTDG3Z4O631CYgZhPHJO4FNTXI+xywOCjOhQDUyBWGimgVeCCeWsqD7+dEX7iKSovvPFCvxmmGnL2T6KSxIYv7WnK0RQN6VNFlFjyEW8I3LnxQb4GO4Pfm9edwuTUIVPXGYrjdSZQyFh2vi3t1cuxdceJ2Mkje2yqgdK+xtOAznTEdgEFkGqfVQlv4dcssCeyuFNsL6KgnQBvM2CX6FRvpAmR2e8sqDCHSEsBbEZrzdsNP+j8ZBSBSxYonkoWwzGWrTv4xyvk+i4BzcD85d5RDgLxa71KCtiiiiFwpQSGzcODJm7+3zc00GMGduJAgFQSP3pkbUh4I75rSi61ozLNUdQsxzQZcIjdBy/osjuRlKNUDIsZnUw9k8qj48qAh7qlKmhCGdmW81Qzbn3t3KYijapECZzlaOU9RNQQCs143B2n07EgetKrYTZyTU81R63nod8oHddZhXcXtS1DKmsjfDQLXklPiaNY07DUwAEJgD0RrOQxcAQcoAb+WlaEHa+7+vwZqlCC1Sj96SMGAzAj8ue58OnGPpuj7Hx01ZQq3AGkoqDaM1s+4cTTIGqZxsiy+854oN+FcGGcTObrF3JKK+fnQej6jwGmQIyqnk3xXsBrDJYNr4/s5xK6eKS0L0hiDz+/zghIPLr86a/nxtMB5qQGGuKYsw29VS7FeQ24XbJw+mO0aEnmHYP1RtnCbk+UKyt3V2q3NtulAiWvV/wumJvc/Z0xJpQVY4jXGz+IV2ejaUW0G78T1yT6JE2ypQod4Y3dIWWuFrXMxl0ru4LGSL+QGbSYeXJ/9q+jaWOWDUG0l65RJXfizjMQZHOzZj3vEor2S3PHUHtC0BgdvFI37X1nO9C77CZrN3n/eB3mWw0APaE7hAFhkKTY+sQtLUmvhxyWxxoAPm5C3cEFITG9zYwX4w8Y6FM9hRchhc3XWw4GYqeUxH4B6a/Ns2gqKEC5ck3q+BAp+cKE+kL07TfEqx9dVTg0lDKExlpHVIDoJwpvexu6M/DqJt8rerO1P/2t9C5YB1gCU3ZiX0Ru4++zp7Men02bVYyM3ZThaacDpR9IJmPoy9LOpoRSwT9Y7UFDNNfo+fl0qY58yVxONHwP+U0257dzT7KYlKqV28NT+OVLJvnZsfUqNF0tTgwffelRwBrRS7qgeENU2lwLnVO908TAQmXzJRsDD/bj3aKL0PiQSRZqbRMBf+c7U8q1BSVFXNoPyHx+lE8IQ891rHgRyCFLaTrip1VquGYGAkAkRrM7QF5qwzziLxpg3j0DJlruQzyz5TbQN6pDWzxVw10amBsVXu9O1chOyaXHqE45pMVk8wRMV5qLMwLu0hdljGXKwKOmhZ781/VYZdNVbSEwwi09x5tHTqQb50683nWtXZFEwTAVLQuzCRKyOux+r7/kjv7zyKlNwLcF7YM00eJAhwzmctVqOqm9gOGN+J69H0EcucIwPQTsaNe/zdhfQnEFxI3re0gCsc2EwVP+q+H8tueE4mXPFI8moZ5WbuM5UdDvuFTSBz9IGMXbl2ETg7s/QAXF09yZa2ZKzwYeCz6z9kKXBgEd8KSm/RprN9lEeZJyEQwxd/Ii2ojcONZ9pe7sr+9J1RxS9/yXYkYWxqmMEiGyA3ubqAdt8mtTEG21aPVnDjYk7svgDPWBX7PgogT7lsPG4vIQb5bEt/67HT0UlIfHeteoXBwuL7q2+aG67M+4LThmM0jWIVXwuAwDvR71kam3ZpyKFKZPmxYoKpm2hs88wvvuqPyOLyFnS8H61CmExlQtO78U9ajmcLl5fiyVLTNGe6TNbb7622eD6z0AaJej4aE+o5i94w/lez/Wf7wexfSvQbc3pXJxlzA2tPvMlzlVz89DWNrdO6FPl/mj2HJ7z+xiw1OL8OD1g5xTTsF2gB7aDmTVcITaB6fXKjs2PggTiptBt5wvClCZb5jc7yrPWKaFzNb5tV1nhagPG5150oIB6K2ftyKuEWUhKdgkDpS6ljMONulBve6yG56EM6K0Xy1J9rDey+u3bbAZWEK7/GP5J6rxNkSUifTTsXf9Pc8hF5wPc0xUZ8qhmvHl7DFWFr+y+8cYtuSrzHFK8iZdCAtY5fBYGy5zI0wUZms5BoM7Ff3ohMkPF7wk+rToU8WFE5WfNgXN7WUvcTlFFkMRUUzkTRWPfR28/STmQdFQiftHRHRYrSlnYjJFRKp0bHy9AHmJTWLBQWASNVjRBtn1V1aLGmZf7tYB2ofbV/DDhxavvJiSN4Kv7tlB60gPNb2ZIP47sGwbBq8t0IOh4nUnPInJeB5nXwc4snNlOwikBZ1bDMy/dYGrW3SyMPuEBz5HlQE2B2AiDjkNCyTfcdY2B7hftXUjYrp1qbs30J3T2nBPulmtL3LoyixVkGDNa8gThShk+USjkbQ3Lk5QbSTyBzczsZ/aqR0Iujt5GFStV69txqu3Yn/CGKr7NCPysWjnCtk8u7i3T6diNqmNa2PSb6TrsCqWW1RLw6oV/366YIbhS3M7zedEOHnp1G/JFHtUkFnSKrc6n4wQYc6VrC4CLgsVvMJ/tz0u/zFKBxzjmBQfGTRJKnO+DAUwV3+V51qT1WY7DfylamOdrtYt19PAXd9IvpxLVTcgpn0BVvNhZ7341QxH74CNj9xTdpErye9aYYlj6E9o3eTd00nmpJGhO2YZixguWtB79IxM2pU2ni5TuVZuqhLWJvTTqTKrv05p4rFSzNtIM24kNDb6paW+YUeVyLw5ruVANnmEMc4lqoHxbjzm0SEpY71FzWbUzpIsgQz6dtkjaspfUm1nDlCFMKZk5ZYglnEyoj2mYEiFj6bkyN6cbB5/O+kV/2BX9gvovy1WwfZ1ifX7fUdoLbT9q8xqKP91qakybEidQ/GSz4nnUKhbhTemAm50/37UI86KtdOwtn9H9mnZdImszcDa/l+pt21sPjcR1bxdGnUlNR9uRqEKZ609hksK/WLtP3vforX8tbmbvXWNGeP+4uN48aHD3G0OWRA6JqT7SHaq2S7VqcNjavY/O72WOWFyiwGTnKfcibcoi0LuMZeJj/wQuzIeqnIZ0Fg4uiyodi3QGTbvFJI0vbawuS82F5OShH3DeERRemUsiesbdihMMMtKS7ULFUzR3bXaKuJqjO+oZP2AlvclVmPBrNPcBhPRl61SACo5ybuaStGGu6i4TuCqM4+PXUnJDYwPifd1/CQnE3/Y5qAxNkMtkvMTvV78rwrSyrEmixnLWJE5cYhl1EOZmfgjZhddjGczrQjI9t/IFyx9rB9ayH2oduV/YPFO93J6dEyVtDi8K/aP1bD6hi3i41CXFzYwnblWkOczlEuKS8oNxK61tm90XQuWvp1pZ8p0dWlyW7VfKI6Qt5Qq58RiYzQ3X9yKb1vfP5USjMgy7GbD4SlTFBXDlRlhhQYw/r3e/ATIZI0I7dbgNO1JknD7QFa89DAkNTKatsX2vOJqzhFoZpiS2fcDPUF2lr9Q9Ajv9y5Mad96JB0Ejj4YNjz4GCcaOz+Cg9Ht76sahIVTsPVqUpvFHu8M/T3hJgINPG2YJ3uwUQT7Axj7ZikfSh2smEUZBP3EGFyuQD/ovZIjOP5qPYdcvW9/+tht1PIh2jbKGxkCR+H5Q1exseM6w6gPL3WfbgLoDfFRctJxx9BlVdbCDALKUUrLxbV1b3jWFtPwfftp7CBz5dS8daYZkvliSYaUHermWR8LShIc9ExOPvguo0NZ75RxvR5tyzbKwcSoRmddoEep8K3NY826snpG/XbXBuZCcTmA0j8W5QxMCXvyb3w/NQVfS86mY/yecvukw/4giaqt5yVj+yX2DJACyiLbdWHCTVneMOIMhSQ2esB/M/1vxUWXZ7C2bVxmOKgdJldlhqbI48fD/pOwUMKWMLA4uQClrCAMWOFpmLWetAVCwUAbcXHfwpv6hyqz56IQv2iBRjHcdeif9OQiGN/rfy9c0X7s8iWlkc7thBWt4kTTib4KTHl6EpL35krU9zWqxEKoJp9rjAFFF8G6d55tZ5xONzXou/uMa7y+iYJUlKaGkG68F6lPgaFctrNECGbBZtlX9By7Wdkzn3kDSPCRj7v4HP/WDRNXxRBnJCKeq7LUOlXnsnt2Cu4TG2iwCPYfpP8BEU/Lqx1nPxxOSDxpfgznrqysC07aOkm7XFw8sfLcRt3KmpWdULv51awetfsbB+vvlr4MDJAnEl/1vXOHjh2+se6qEF+QFruLpALeEIqpb1QsoXZ6GplVYZcFH4LlQkfnAkKle8oqC2v7ZGQipGnIIiZsvvxJXiF5rysl2Pr0VfVdy781osTqTzIPaWwJvGM7GgwY5KIqYu7G8k238Ee7kLTbOUru5BEVg40uC1qKhOC67Jmb+iwS3NqSWkukt6Cj1kP9f67Y3M8Lz7+JAZnkpQPN6kN7vEFxQ+GTs0XRQySStWcj3nrARCCh9cJ0mzr2Ib46Z0Mx4Ya2ltmTwC8LNwiZPb3/zn7a0V0a0Gi4nWmjMmZ3xU0U6I1SIsvP+4SDxZzkS5gBlcfloEGtq4LJ8VYVj47cy62PnhHpVAhVkmz7EguQVZsXkK3zceyUIwAjN96zsncS2uiTSF91+s//0Q7tg7u7SKETCSUC8NGPnOA2yI571tziEfOuAGVjxc1bZHlNBfB/yfSEUvPbSCKkaO4ziBl4/LTRbYy71r4M7y1JlOCau8zwdrOoTavTmrryb4VAhSFw5fY3QX/ftJjM+TJ8cuzDJjO2dcWs+4p/kaliteywiWJ6lqYk8PWKIvxfJyrJZ/i962TcnujPIx+ErnRb3q0lkWF3OpKAe9Q6XYz67RKU6agrOOVpjPKcaRWZ7e2jmQMX/3eGdjOrbW59+13vn4idKEFLFWZ3VNlxM4LwX4uucHimVkWs2OKonnwb1/HgNUQx0UBZo3jhy1x+XoJzQvV2uhNlFYUUTlLQHB3NCDag== </div>]]></content>
    
    <summary type="html">
    
      猜猜会写些啥
    
    </summary>
    
      <category term="随感" scheme="http://zhangcabbage.cn/categories/%E9%9A%8F%E6%84%9F/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="总结" scheme="http://zhangcabbage.cn/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>书评(一)：Java多线程编程核心技术</title>
    <link href="http://zhangcabbage.cn/2017/%E4%B9%A6%E8%AF%84-%E4%B8%80-%EF%BC%9AJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html"/>
    <id>http://zhangcabbage.cn/2017/书评-一-：Java多线程编程核心技术.html</id>
    <published>2017-01-19T07:51:05.000Z</published>
    <updated>2017-02-03T13:49:44.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>古人言：读万卷书，行万里路。读书的重要性自不必说，然而怎奈何有限的时间与无尽的兴趣爱好的矛盾，让我深刻感受到把时间投入到读好书的重要性。</p><p>所以为了帮助广大书友，尤其是跟我一样同为程序猿的勤奋好学的小伙伴们，这里开<code>书评系列</code>博文（努力写下去，认真脸…），主要用来总结已看过的书，并推荐好书。这里采用星级评价：<strong>5星为力荐</strong>（握草，神书，快来看啊），<strong>1星为呵</strong>（看完后我的内心基本毫无波澜），<strong>0星为呵呵哒</strong>（哔了狗，看书的时间还不如看毛片，有个电视剧叫毛骗，很好看，认真脸）。</p><p>关于行文方式，本站博文力求把想展示的结果放在最显眼的部位，让大家能一眼辨别是不是你的菜，力求简洁并尝试幽默（古板脸.jpg）。</p><p>本系列第一篇是<strong>《Java多线程编程核心技术》，推荐力度：★☆☆☆☆</strong><br>有一定基础，想深入Java多线程编程的胖友们可以忽略本书。<br><a id="more"></a></p><h2 id="读后感"><a href="#读后感" class="headerlink" title="读后感"></a>读后感</h2><p>首先用一句话来总结这本书：<strong>本书偏向于Java多线程API方面的使用教程，仅用代码栗子来说明如何使用，而没有更深入的剖析讲解</strong>。</p><p>本书共分为7章，针对Java多线程从7个方面来描述。</p><ul><li>第1章从Java中线程的基本使用说起：<code>新建线程</code>、<code>停止线程</code>、<code>暂停线程</code>、<code>线程优先级</code>等。线程的停止和暂停方法还是有一定的可读性。</li><li>第2章主要讲对象变量的多线程并发同步：主要是<code>synchronized和volatile的使用</code>。本章可读性不强，各种code举例，然而却没有深入剖析，知其然而不知其所以然。</li><li>第3章讲线程通信：<code>wait和notify机制</code>，<code>join</code>、<code>ThreadLocal</code>、<code>InheritalbeThreadLocal的使用</code>。本章生产者消费者模式部分略微有一定的可读性，其余仅仅API使用说明。</li><li>第4章和第5章分别是<code>另一种加锁方式Lock</code>和<code>定时器Timer的使用</code>说明。</li><li>第6章着重讲解<code>多线程下单例模式的实现</code>，但是同样仅仅举栗子说明，说明不够透彻（不如看博文，后面将写一篇关于单例模式的深入一点的剖析讲解博文，敬请期待，哈哈哈…）</li><li>最后第7章增补了关于<code>线程状态</code>、<code>线程组</code>、<code>线程和线程组异常处理</code>方面的使用说明。</li></ul><p>初学者看看使用还可以，然而想深入专研Java多线程编程的同学还是出门右转。</p><blockquote><p>受限于博主个人知识面，以上仅个人看法，欢迎批评指正。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;古人言：读万卷书，行万里路。读书的重要性自不必说，然而怎奈何有限的时间与无尽的兴趣爱好的矛盾，让我深刻感受到把时间投入到读好书的重要性。&lt;/p&gt;&lt;p&gt;所以为了帮助广大书友，尤其是跟我一样同为程序猿的勤奋好学的小伙伴们，这里开&lt;code&gt;书评系列&lt;/code&gt;博文（努力写下去，认真脸…），主要用来总结已看过的书，并推荐好书。这里采用星级评价：&lt;strong&gt;5星为力荐&lt;/strong&gt;（握草，神书，快来看啊），&lt;strong&gt;1星为呵&lt;/strong&gt;（看完后我的内心基本毫无波澜），&lt;strong&gt;0星为呵呵哒&lt;/strong&gt;（哔了狗，看书的时间还不如看毛片，有个电视剧叫毛骗，很好看，认真脸）。&lt;/p&gt;&lt;p&gt;关于行文方式，本站博文力求把想展示的结果放在最显眼的部位，让大家能一眼辨别是不是你的菜，力求简洁并尝试幽默（古板脸.jpg）。&lt;/p&gt;&lt;p&gt;本系列第一篇是&lt;strong&gt;《Java多线程编程核心技术》，推荐力度：★☆☆☆☆&lt;/strong&gt;&lt;br&gt;有一定基础，想深入Java多线程编程的胖友们可以忽略本书。&lt;br&gt;
    
    </summary>
    
      <category term="书籍" scheme="http://zhangcabbage.cn/categories/%E4%B9%A6%E7%B1%8D/"/>
    
    
      <category term="随感" scheme="http://zhangcabbage.cn/tags/%E9%9A%8F%E6%84%9F/"/>
    
      <category term="书评" scheme="http://zhangcabbage.cn/tags/%E4%B9%A6%E8%AF%84/"/>
    
  </entry>
  
  <entry>
    <title>17年网易有道内推笔试---构造队列</title>
    <link href="http://zhangcabbage.cn/2017/17%E5%B9%B4%E7%BD%91%E6%98%93%E6%9C%89%E9%81%93%E5%86%85%E6%8E%A8%E7%AC%94%E8%AF%95-%E6%9E%84%E9%80%A0%E9%98%9F%E5%88%97.html"/>
    <id>http://zhangcabbage.cn/2017/17年网易有道内推笔试-构造队列.html</id>
    <published>2017-01-14T13:55:27.000Z</published>
    <updated>2017-01-15T03:22:48.000Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:01 GMT+0800 (CST) --><p>无意中看到这道笔试题，想想自己已经估摸快一个多月没有刷算法题；简直羞愧难当，越来越水了，就试试当热热手…</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小明同学把1到n这n个数字按照一定的顺序放入了一个队列Q中。现在他对队列Q执行了如下程序：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">while(!Q.empty()) //队列不空，执行循环</span><br><span class="line">&#123;</span><br><span class="line">    int x=Q.front(); //取出当前队头的值x</span><br><span class="line">    Q.pop(); //弹出当前队头</span><br><span class="line">    Q.push(x); //把x放入队尾</span><br><span class="line">    x = Q.front(); //取出这时候队头的值</span><br><span class="line">    printf(&quot;%d\n&quot;,x); //输出x</span><br><span class="line">    Q.pop(); //弹出这时候的队头</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>做取出队头的值操作的时候，并不弹出当前队头。小明同学发现，这段程序恰好按顺序输出了1,2,3,…,n。现在小明想让你构造出原始的队列，你能做到吗？<br><strong>输入描述:</strong><br>第一行一个整数T（T ≤ 100）表示数据组数，每组数据输入一个数n（1 ≤ n ≤ 100000），输入的所有n之和不超过200000。<br><strong>输出描述:</strong><br>对于每组数据，输出一行，表示原始的队列。数字之间用一个空格隔开，不要在行末输出多余的空格.<br><strong>输入例子:</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p></p><p><strong>输出例子:</strong><br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2 1</span><br><span class="line">2 1 3</span><br><span class="line">8 1 6 2 10 3 7 4 9 5</span><br></pre></td></tr></table></figure><p></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>首先只考虑f(n)输出<code>1, 2, 3...n</code>，我第一念头是按照程序逻辑逆推，按照<code>n, n-1 ... 3, 2, 1</code>的顺序把全部元素回插入队列。先只分析<code>1, 2, 3</code>的情况：首先回插3，队列集合为<code>[3]</code>；之后回插2，根据输出逻辑，当回插时每次需要把最后一个元素移至队列头，此时队列集合为<code>[3, 2]</code>；最后回插1，同理得队列集合为<code>[2, 1, 3]</code>。ok逆推成功，这道题不是还是挺容易的。<br>Java程序如下所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateQueue1</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        list.add(<span class="number">0</span>, i);</span><br><span class="line">        list.add(<span class="number">0</span>, list.get(list.size() - <span class="number">1</span>));</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(list.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>当然如果这道题分析仅仅是这样的话，那这篇博文也没有啥写的必要了。各位看官，你看到这里时，有啥别的想法思路不？后面紧接着将记录几个新颖的解题思路，虽然最后证明上面简单的逆推算法效率上基本是最高的，但是新奇的思路总是显得比较好玩。</p><h2 id="头脑风暴"><a href="#头脑风暴" class="headerlink" title="头脑风暴"></a>头脑风暴</h2><h3 id="开胃菜"><a href="#开胃菜" class="headerlink" title="开胃菜"></a>开胃菜</h3><p>这盘开胃菜的主要思路如下：</p><blockquote><p>以<code>1, 2 ... n-1, n</code>为原始队列元素，按照题目队列输出逻辑操作得到输出结果，之后以输出结果的值为下标把对应数组处填入值对应的下标。</p></blockquote><p>上面这句话可能比较拗口难以理解，我们举个栗子来说明一下：假如n=3，此时队列为[1, 2, 3]，通过输出逻辑输出结果数组<code>2, 1, 3</code>，其对应的下标为<code>1, 2, 3</code>。那么我们填入结果数组res方式为：<code>res[2] = 1, res[1] = 2, res[3] = 3</code>。（注意：上述栗子中为了方便说明，下标没有从0开始）<br>Java程序如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">generateQueue2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; original = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        original.add(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (original.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        original.add(original.get(<span class="number">0</span>));</span><br><span class="line">        original.remove(<span class="number">0</span>);</span><br><span class="line">        tmp[i++] = original.get(<span class="number">0</span>);</span><br><span class="line">        original.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        res[tmp[j] - <span class="number">1</span>] = j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        System.out.print(res[j] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>通过上面的程序我们可以看到，虽然时间复杂度也为O(n)，但是其系数比逆推方法大。(能听我啰嗦看到这里了，简直是真爱！最重要的来了，那就继续往下看吧…)</p><h3 id="主菜"><a href="#主菜" class="headerlink" title="主菜"></a>主菜</h3><p>下面主菜来了，我看到讨论区有不少人说可以用<a href="https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98" target="_blank" rel="noopener">约瑟夫环</a>。不懂<code>约瑟夫环</code>的胖友们得纠结了，啥叫<code>约瑟夫环</code>呀，听着好高端的样子。后面我会单独开一篇约瑟夫环问题的剖析，其精髓就是：<strong>约瑟夫环的前后状态间可以相互迭代推导，下标之间可以很容易实现转换</strong>。建议大家在了解约瑟夫环的前提下，进一步思考这道题如何使用约瑟夫环来进行分析，后面我将假设大家对约瑟夫环有一定的了解。(ヾ(｡｀Д´｡)刚说让我继续往下看，现在又来这一手，玩我呢[掀桌子…)</p><p>别打我，其实也并不需要太深入了解，后面都会用直白的栗子说明，看得懂的啦。这里是希望大家看完这道题，去了解约瑟夫环之后，能再回过来想一下下面我的解题方式，或许可以帮助大家更深入理解约瑟夫环问题。</p><p>约瑟夫环解题思路：通过迭代来帮助我们把[0,1]范围内的问题解，映射到[0,2]，之后继续向上映射最终得到[0,n-1]范围内的解。根据题意(我擦，这句话好像做数学应用题的套路)：对于队列<code>0, 1, 2, 3 ... n-2, n-1</code>，获取第一个元素后队列为<code>2, 3, 4, 5 ... n-2, n-1, 0</code>，我们可以把这个队列通过<code>(x - 2 + n) % n</code>转化为<code>0, 1, 2, 3 ... n-3, n-2</code>。反过来，也可以把<code>0, 1, 2, 3 ... n-3, n-2</code>通过<code>(x + 2) % n</code>向上映射成<code>0, 1, 2, 3 ... n-2, n-1</code>。故[0,n-2]内遍历的第一个元素，通过<code>(x + 2) % i</code>可以转化为[0, n-1]内遍历的第二个元素。</p><p>通过上面的思路分析，我们可以知道，<code>约瑟夫环问题</code>可以把下层(规模小的问题)中也是上层(规模大的问题)的解层层映射，最终迭代转换成想要求得问题规模的解。这里要注意：<strong>要求的问题规模下的解需要也在下层(规模小的问题)中才能进行转化</strong>。</p><p>那么有了上面的分析，这道题该继续怎么进行解答呢？考虑到我们可以很容易的求得任何问题规模下的第一个遍历元素下标，有如下思路：</p><blockquote><p><code>[0, n-2]</code>第1次遍历 –&gt; 是<code>[0, n-1]</code>中第2次遍历的下标, 迭代1次<br><code>[0, n-3]</code>第1次遍历 –&gt; 是<code>[0, n-1]</code>中第3次遍历的下标, 迭代2次<br>.<br>.<br>.<br><code>[0, 1]</code>第1次遍历 –&gt; 是<code>[0, n-1]</code>中第n-1次遍历的下标, 迭代n-2次<br><code>[0, 0]</code>第1次遍历 –&gt; 是<code>[0, n-1]</code>中第n遍历的下标, 迭代n-1次</p></blockquote><p>Java程序如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">generateQueue3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[n]; <span class="comment">//结果数组</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>; <span class="comment">//表示第几个遍历的元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">1</span>) res[<span class="number">1</span>] = x++; <span class="comment">//第1个下标是1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">2</span>; i++) &#123; <span class="comment">//后续第2~n-1个元素下标</span></span><br><span class="line">        index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - i; j &lt;= n; j++) &#123;</span><br><span class="line">            index = (index + <span class="number">2</span>) % j;</span><br><span class="line">        &#125;</span><br><span class="line">        res[index] = x++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    index = <span class="number">0</span>; <span class="comment">//最后第n个元素下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        index = (index + <span class="number">2</span>) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    res[index] = x;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        System.out.print(res[i] + <span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>很明显我们可以知道我上述约瑟夫环的方式，时间复杂度为O(n^2)</p><blockquote><p>以上方法要么是原创，要么是根据别人思路自己想的，受限于自身知识可能解决问题的方法不是很好，如果大家有更好的这个思路下的解法欢迎留言。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:01 GMT+0800 (CST) --&gt;&lt;p&gt;无意中看到这道笔试题，想想自己已经估摸快一个多月没有刷算法题；简直羞愧难当，越来越水了，就试试当热热手…&lt;/p&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小明同学把1到n这n个数字按照一定的顺序放入了一个队列Q中。现在他对队列Q执行了如下程序：&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;while(!Q.empty()) //队列不空，执行循环&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    int x=Q.front(); //取出当前队头的值x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q.pop(); //弹出当前队头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q.push(x); //把x放入队尾&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    x = Q.front(); //取出这时候队头的值&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;%d\n&amp;quot;,x); //输出x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    Q.pop(); //弹出这时候的队头&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="http://zhangcabbage.cn/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://zhangcabbage.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="约瑟夫环" scheme="http://zhangcabbage.cn/tags/%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>视频剪辑</title>
    <link href="http://zhangcabbage.cn/2017/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91.html"/>
    <id>http://zhangcabbage.cn/2017/视频剪辑.html</id>
    <published>2017-01-11T12:14:44.000Z</published>
    <updated>2018-02-02T12:59:04.053Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>16年7月份开始在github上搭建个人博客，之后博客却是没怎么装扮。我是个什么东西都先看美感的人，对于一个没有美感的博客自然提不起劲登录更新了。最近终于得空（好吧，是我终于想起来这一茬…），装扮了一下博客，测试一下markdown发布链接、图片、视频等的功能用法。<br><a id="more"></a></p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>那我就不扯淡，赶紧进入正题。这篇文章主要是关于14年2月份，过年在家看完只有4集的韩国棒子片《<a href="http://baike.baidu.com/link?url=ORbrwVyeltFU_4oJL7y-raYNC5QZhj2xDWLqohKtxg4V2o1AjcO64-oM0sMj6_bru8fARxRsZyLQ3IVzUPm3TiO_O8yD-km6z95Cay9o_Q_" target="_blank" rel="noopener">二十岁</a>》，由于当时正在学习<a href="https://zh.wikipedia.org/wiki/Adobe_After_Effects" target="_blank" rel="noopener">AE</a>又正好听到几首比较带感的音乐，就突发奇想尝试一下<code>视频剪辑</code>。全凭感觉，主要是对音乐有感。<br>先放一张我的视频大作的封面，封面周围进行模糊化，<code>二十岁</code>这四个字(啊，不对是两个字，是几个字来着…)，是我进行拆分后，用AE做了个随机化运动然后在进行合并(网上有教程，当时就这样边学边开始卖了，在贴吧骗小姑凉，捂脸..)<br><img src="/images/videoClip/pic_hd.jpg" alt=""><br>下面是视频：<br>我是想直接把视频嵌入到文章页面中来着，但是这个视频我但是发布到土豆上了，查了一下没发现好的解决办法，暂时就直接放链接吧<br><a href="http://www.tudou.com/programs/view/TUG2B_mhsWk/?resourceId=0_06_02_99" target="_blank" rel="noopener">断点</a></p><blockquote><p>BGM：断点 - 张敬轩<br>素材：韩剧二十岁<br>主演：李起光，李多仁<br>片尾曲：Rain - 秦基博<br>软件：AE<br>制作人：鬼少/张一剪(就是我啰)</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      &lt;!-- build time:Sun Feb 04 2018 14:25:02 GMT+0800 (CST) --&gt;&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;16年7月份开始在github上搭建个人博客，之后博客却是没怎么装扮。我是个什么东西都先看美感的人，对于一个没有美感的博客自然提不起劲登录更新了。最近终于得空（好吧，是我终于想起来这一茬…），装扮了一下博客，测试一下markdown发布链接、图片、视频等的功能用法。&lt;br&gt;
    
    </summary>
    
      <category term="视频" scheme="http://zhangcabbage.cn/categories/%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="视频剪辑" scheme="http://zhangcabbage.cn/tags/%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    
  </entry>
  
</feed>
